<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Semiconductor War — Admin Panel</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0e17;
      color: #e0e6ed;
      font-family: 'Share Tech Mono', monospace;
      padding: 20px;
      min-height: 100vh;
    }
    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.6rem;
      color: #ffd700;
      margin-bottom: 6px;
    }
    h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      color: #a0aec0;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .header { margin-bottom: 20px; }
    .header .subtitle { color: #6b7a8d; font-size: 0.8rem; }

    /* Auth */
    #authPanel {
      max-width: 360px;
      margin: 80px auto;
      text-align: center;
    }
    #authPanel input {
      width: 100%;
      padding: 12px;
      background: #141c28;
      border: 1px solid #2a3a4e;
      border-radius: 6px;
      color: #e0e6ed;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1rem;
      margin-bottom: 12px;
      outline: none;
    }
    #authPanel input:focus { border-color: #ffd700; }
    #authPanel button {
      padding: 10px 32px;
      background: #ffd700;
      border: none;
      border-radius: 6px;
      color: #0a0e17;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      cursor: pointer;
    }
    #authPanel button:hover { background: #ffed4a; }
    #authError { color: #ef4444; margin-top: 8px; font-size: 0.8rem; }

    /* Main panel */
    #mainPanel { display: none; }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 20px;
    }
    .card {
      background: #141c28;
      border: 1px solid #2a3a4e;
      border-radius: 8px;
      padding: 16px;
    }
    .card.full { grid-column: 1 / -1; }

    /* Status */
    .status-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid rgba(42,58,78,0.3);
      font-size: 0.8rem;
    }
    .status-row:last-child { border-bottom: none; }
    .status-label { color: #6b7a8d; }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 0.65rem;
      font-weight: 700;
    }
    .badge.open { background: rgba(34,197,94,0.2); color: #22c55e; }
    .badge.closed { background: rgba(107,122,141,0.2); color: #6b7a8d; }
    .badge.active { background: rgba(251,191,36,0.2); color: #fbbf24; }
    .badge.expired { background: rgba(107,122,141,0.2); color: #6b7a8d; }
    .badge.cancelled { background: rgba(239,68,68,0.2); color: #ef4444; }

    /* Event form */
    .form-group { margin-bottom: 12px; }
    .form-group label {
      display: block;
      font-size: 0.7rem;
      color: #6b7a8d;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }
    .form-group select,
    .form-group input {
      width: 100%;
      padding: 8px;
      background: #0a0e17;
      border: 1px solid #2a3a4e;
      border-radius: 4px;
      color: #e0e6ed;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.85rem;
      outline: none;
    }
    .form-group select:focus,
    .form-group input:focus { border-color: #ffd700; }
    .form-row { display: flex; gap: 10px; }
    .form-row .form-group { flex: 1; }
    .dynamic-fields { margin-top: 8px; }

    .btn {
      padding: 8px 24px;
      border: none;
      border-radius: 4px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 0.75rem;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .btn-primary { background: #ffd700; color: #0a0e17; }
    .btn-primary:hover { background: #ffed4a; }
    .btn-danger { background: #ef4444; color: #fff; }
    .btn-danger:hover { background: #f87171; }
    .btn-sm {
      padding: 4px 12px;
      font-size: 0.65rem;
    }

    #eventResult {
      margin-top: 8px;
      font-size: 0.8rem;
      min-height: 20px;
    }
    .result-ok { color: #22c55e; }
    .result-err { color: #ef4444; }

    /* Events list */
    .event-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(42,58,78,0.3);
      font-size: 0.8rem;
    }
    .event-item:last-child { border-bottom: none; }
    .event-meta { color: #6b7a8d; font-size: 0.7rem; }

    /* News */
    .news-item {
      padding: 6px 0;
      border-bottom: 1px solid rgba(42,58,78,0.3);
      font-size: 0.8rem;
    }
    .news-item:last-child { border-bottom: none; }
    .news-corp { color: #ffd700; font-size: 0.7rem; }
    .empty { color: #4a5568; font-size: 0.8rem; font-style: italic; }

    /* Map buttons */
    .map-btn-row { display: flex; gap: 10px; margin-top: 10px; }
    .map-btn-admin {
      flex: 1;
      padding: 12px;
      background: #0a0e17;
      border: 2px solid #2a3a4e;
      border-radius: 6px;
      color: #e0e6ed;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    .map-btn-admin:hover { border-color: #ffd700; background: rgba(255,215,0,0.05); }
    .map-btn-admin.active { border-color: #22c55e; background: rgba(34,197,94,0.1); color: #22c55e; }
    .map-btn-admin .map-sub { display: block; font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: #6b7a8d; margin-top: 4px; font-weight: 400; }

    /* News management */
    .news-custom-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid rgba(42,58,78,0.3);
      font-size: 0.8rem;
    }
    .news-custom-item:last-child { border-bottom: none; }
    .news-add-form { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
    .news-add-form input, .news-add-form select {
      padding: 8px;
      background: #0a0e17;
      border: 1px solid #2a3a4e;
      border-radius: 4px;
      color: #e0e6ed;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.8rem;
      outline: none;
    }
    .news-add-form input:focus, .news-add-form select:focus { border-color: #ffd700; }
    .news-add-form input { flex: 2; min-width: 200px; }
    .news-add-form select { flex: 1; min-width: 120px; }
    .section-label {
      font-size: 0.7rem;
      color: #6b7a8d;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 12px 0 6px;
    }

    /* Chat management */
    .chat-item {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
      padding: 6px 0;
      border-bottom: 1px solid rgba(42,58,78,0.3);
      font-size: 0.8rem;
    }
    .chat-item:last-child { border-bottom: none; }
    .chat-meta { color: #4a5568; font-size: 0.7rem; }
    .chat-team-sam { color: #5a9bff; font-weight: 700; }
    .chat-team-skh { color: #ff6b80; font-weight: 700; }
    .chat-system { color: #ffd700; font-style: italic; font-size: 0.75rem; }

    /* User Management */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-bottom: 16px;
    }
    .stat-card {
      background: #0a0e17;
      border: 1px solid #2a3a4e;
      border-radius: 6px;
      padding: 12px;
      text-align: center;
    }
    .stat-card .stat-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.4rem;
      color: #ffd700;
      display: block;
    }
    .stat-card .stat-label {
      font-size: 0.65rem;
      color: #6b7a8d;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 4px;
    }
    .search-bar {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    .search-bar input {
      flex: 1;
      padding: 8px 12px;
      background: #0a0e17;
      border: 1px solid #2a3a4e;
      border-radius: 4px;
      color: #e0e6ed;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.85rem;
      outline: none;
    }
    .search-bar input:focus { border-color: #ffd700; }
    .search-bar select {
      padding: 8px;
      background: #0a0e17;
      border: 1px solid #2a3a4e;
      border-radius: 4px;
      color: #e0e6ed;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.8rem;
      outline: none;
    }
    .user-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }
    .user-table th {
      text-align: left;
      padding: 8px 6px;
      border-bottom: 2px solid #2a3a4e;
      color: #6b7a8d;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .user-table td {
      padding: 8px 6px;
      border-bottom: 1px solid rgba(42,58,78,0.3);
      vertical-align: middle;
    }
    .user-table tr:hover td { background: rgba(255,215,0,0.03); }
    .uuid-short {
      font-size: 0.7rem;
      color: #4a5568;
      font-family: 'Share Tech Mono', monospace;
    }
    .nick-list { font-size: 0.75rem; color: #a0aec0; }
    .pagination {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 12px;
    }
    .pagination button {
      padding: 4px 12px;
      background: #0a0e17;
      border: 1px solid #2a3a4e;
      border-radius: 4px;
      color: #e0e6ed;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .pagination button:hover { border-color: #ffd700; }
    .pagination button:disabled { opacity: 0.3; cursor: not-allowed; }
    .pagination .page-info { padding: 4px 8px; color: #6b7a8d; font-size: 0.8rem; }

    /* User Detail Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-overlay.show { display: flex; }
    .modal-content {
      background: #141c28;
      border: 1px solid #2a3a4e;
      border-radius: 8px;
      padding: 24px;
      max-width: 700px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-close {
      float: right;
      background: none;
      border: none;
      color: #6b7a8d;
      font-size: 1.2rem;
      cursor: pointer;
    }
    .modal-close:hover { color: #ffd700; }
    .detail-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid rgba(42,58,78,0.3);
      font-size: 0.8rem;
    }
    .detail-row:last-child { border-bottom: none; }
    .session-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
      margin-top: 12px;
    }
    .session-table th {
      text-align: left;
      padding: 6px 4px;
      border-bottom: 2px solid #2a3a4e;
      color: #6b7a8d;
      font-size: 0.65rem;
      text-transform: uppercase;
    }
    .session-table td {
      padding: 6px 4px;
      border-bottom: 1px solid rgba(42,58,78,0.2);
    }

    /* Battle Test Mode */
    .battle-layout { display: flex; gap: 16px; }
    .battle-setup { width: 240px; flex-shrink: 0; }
    .battle-canvas-wrap { flex: 1; min-width: 0; }
    .battle-group { margin-bottom: 14px; }
    .battle-group .group-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      color: #ffd700;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(255,215,0,0.2);
    }
    .battle-group select, .battle-group input[type="range"] {
      width: 100%;
      padding: 6px 8px;
      background: #0a0e17;
      border: 1px solid #2a3a4e;
      border-radius: 4px;
      color: #e0e6ed;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.8rem;
      outline: none;
      margin-bottom: 6px;
    }
    .battle-group select:focus { border-color: #ffd700; }
    .battle-group .level-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .battle-group .level-row input { flex: 1; }
    .battle-group .level-row span {
      font-size: 0.75rem;
      color: #ffd700;
      min-width: 36px;
      text-align: right;
    }
    .battle-controls { display: flex; gap: 8px; margin: 10px 0; flex-wrap: wrap; }
    .battle-results {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-top: 10px;
    }
    .battle-stat {
      background: #0a0e17;
      border: 1px solid #2a3a4e;
      border-radius: 4px;
      padding: 6px 8px;
      text-align: center;
    }
    .battle-stat .bstat-val {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      color: #ffd700;
      display: block;
    }
    .battle-stat .bstat-label {
      font-size: 0.6rem;
      color: #6b7a8d;
      text-transform: uppercase;
    }
    .battle-stat.winner { border-color: #22c55e; }
    .battle-entity-info {
      font-size: 0.7rem;
      color: #6b7a8d;
      margin-top: 4px;
      line-height: 1.4;
    }
    .battle-entity-info .bei-hp { color: #22c55e; }
    .battle-entity-info .bei-dmg { color: #ef4444; }
    .battle-entity-info .bei-spd { color: #60a5fa; }
    @media (max-width: 768px) {
      .battle-layout { flex-direction: column; }
      .battle-setup { width: 100%; }
    }

    /* Refresh indicator */
    .refresh-bar {
      height: 2px;
      background: #ffd700;
      position: fixed;
      top: 0;
      left: 0;
      animation: refresh-progress 5s linear infinite;
    }
    @keyframes refresh-progress {
      0% { width: 0; }
      100% { width: 100%; }
    }
  </style>
</head>
<body>
  <!-- Auth -->
  <div id="authPanel">
    <h1>ADMIN PANEL</h1>
    <p style="color:#6b7a8d;margin-bottom:24px">Semiconductor War</p>
    <input type="password" id="passwordInput" placeholder="Admin Password" autofocus>
    <br>
    <button onclick="authenticate()">LOGIN</button>
    <div id="authError"></div>
  </div>

  <!-- Main -->
  <div id="mainPanel">
    <div class="refresh-bar"></div>
    <div class="header">
      <h1>SEMICONDUCTOR WAR — ADMIN</h1>
      <p class="subtitle">Event System &amp; Market Data Monitor</p>
    </div>

    <div class="grid">
      <!-- Map Management -->
      <div class="card full">
        <h2>Map Management</h2>
        <div id="gameStatus"><span class="empty">Loading...</span></div>
        <div class="map-btn-row">
          <button class="map-btn-admin" id="mapBtn_tribus" onclick="changeMap('map_tribus_circuit')">
            Tri-Bus Circuit
            <span class="map-sub">3-Lane · Via Portals · Boss</span>
          </button>
          <button class="map-btn-admin" id="mapBtn_wafer" onclick="changeMap('map_wafer_ring')">
            Wafer Ring Arena
            <span class="map-sub">Circular · Die Tiles · Events</span>
          </button>
        </div>
      </div>

      <!-- Today's Top Players -->
      <div class="card">
        <h2>Today's Top Players</h2>
        <div id="dailyRecordsCount" style="font-size:0.75rem;color:#6b7a8d;margin-bottom:8px">0 players</div>
        <div id="dailyRecordsList" style="max-height:300px;overflow-y:auto"><span class="empty">Loading...</span></div>
      </div>

      <!-- Market Status -->
      <div class="card">
        <h2>Market Status</h2>
        <div id="marketStatus"><span class="empty">Loading...</span></div>
      </div>

      <!-- Provider Status -->
      <div class="card">
        <h2>Provider Status</h2>
        <div id="providerStatus"><span class="empty">Loading...</span></div>
      </div>

      <!-- Compliance Check -->
      <div class="card full">
        <h2>Compliance Check</h2>
        <div id="complianceCheck"><span class="empty">Loading...</span></div>
      </div>

      <!-- News Management -->
      <div class="card full">
        <h2>News Management</h2>
        <div class="news-add-form">
          <input type="text" id="newsTitle" placeholder="뉴스 제목">
          <select id="newsCorpName">
            <option value="삼성전자">삼성전자</option>
            <option value="SK하이닉스">SK하이닉스</option>
          </select>
          <select id="newsTeam">
            <option value="samsung">Samsung</option>
            <option value="skhynix">SK Hynix</option>
          </select>
          <select id="newsType">
            <option value="custom">Custom</option>
            <option value="announcement">Announcement</option>
            <option value="earnings">Earnings</option>
            <option value="partnership">Partnership</option>
          </select>
          <button class="btn btn-primary btn-sm" onclick="addNews()">ADD</button>
        </div>
        <div id="newsResult" style="font-size:0.8rem;min-height:16px;margin-bottom:8px"></div>
        <div class="section-label">Custom News</div>
        <div id="customNewsList"><span class="empty">No custom news</span></div>
        <div class="section-label" style="margin-top:16px">Provider News</div>
        <div id="providerNewsList" style="max-height:200px;overflow-y:auto"><span class="empty">Loading...</span></div>
      </div>

      <!-- Create Event -->
      <div class="card full">
        <h2>Create Event</h2>
        <div class="form-row">
          <div class="form-group">
            <label>Event Type</label>
            <select id="eventType" onchange="updateDynamicFields()">
              <option value="BOSS_SPAWN">BOSS_SPAWN</option>
              <option value="ZONE_MODIFIER">ZONE_MODIFIER</option>
              <option value="GLOBAL_PARAM">GLOBAL_PARAM</option>
              <option value="NEWS_TICKER">NEWS_TICKER</option>
            </select>
          </div>
          <div class="form-group">
            <label>Title</label>
            <input type="text" id="eventTitle" placeholder="Event title">
          </div>
          <div class="form-group">
            <label>Duration (ms)</label>
            <input type="number" id="eventDuration" value="60000" min="10000" max="300000">
          </div>
        </div>
        <div id="dynamicFields" class="dynamic-fields"></div>
        <div style="margin-top:12px">
          <button class="btn btn-primary" onclick="createEvent()">TRIGGER EVENT</button>
        </div>
        <div id="eventResult"></div>
      </div>

      <!-- Active Events -->
      <div class="card">
        <h2>Active Events</h2>
        <div id="activeEvents"><span class="empty">No active events</span></div>
      </div>

      <!-- Recent Events -->
      <div class="card">
        <h2>Recent Events</h2>
        <div id="recentEvents"><span class="empty">No recent events</span></div>
      </div>

      <!-- Chat Management -->
      <div class="card full">
        <h2>Chat Management</h2>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
          <span id="chatCount" style="font-size:0.8rem;color:#6b7a8d">0 messages</span>
          <button class="btn btn-danger btn-sm" onclick="clearAllChat()">CLEAR ALL</button>
        </div>
        <div id="chatList" style="max-height:400px;overflow-y:auto"><span class="empty">Loading...</span></div>
      </div>

      <!-- User Management -->
      <div class="card full">
        <h2>User Management</h2>
        <div class="stats-grid" id="userStatsGrid">
          <div class="stat-card"><span class="stat-value" id="statTotalUsers">-</span><span class="stat-label">Total Users</span></div>
          <div class="stat-card"><span class="stat-value" id="statTodayActive">-</span><span class="stat-label">Today Active</span></div>
          <div class="stat-card"><span class="stat-value" id="statOnlineNow">-</span><span class="stat-label">Online Now</span></div>
          <div class="stat-card"><span class="stat-value" id="statTotalSessions">-</span><span class="stat-label">Total Sessions</span></div>
          <div class="stat-card"><span class="stat-value" id="statAvgPlaytime">-</span><span class="stat-label">Avg Playtime</span></div>
        </div>
        <div class="search-bar">
          <input type="text" id="userSearchInput" placeholder="Search by nickname or UUID..." onkeydown="if(event.key==='Enter')searchUsers()">
          <select id="userSortSelect" onchange="searchUsers()">
            <option value="lastSeen">Last Seen</option>
            <option value="visitCount">Visit Count</option>
            <option value="totalScore">Score</option>
            <option value="totalPlaytimeMs">Playtime</option>
            <option value="firstSeen">First Seen</option>
          </select>
          <button class="btn btn-primary btn-sm" onclick="searchUsers()">SEARCH</button>
        </div>
        <div style="overflow-x:auto">
          <table class="user-table">
            <thead>
              <tr>
                <th>UUID</th>
                <th>Nicknames</th>
                <th>Team</th>
                <th>Visits</th>
                <th>Score</th>
                <th>Playtime</th>
                <th>Last Seen</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="userTableBody">
              <tr><td colspan="8" class="empty">Loading...</td></tr>
            </tbody>
          </table>
        </div>
        <div class="pagination" id="userPagination"></div>
      </div>

      <!-- User Detail Modal -->
      <div class="modal-overlay" id="userDetailModal">
        <div class="modal-content">
          <button class="modal-close" onclick="closeUserDetail()">&times;</button>
          <h2 style="margin-bottom:16px">User Detail</h2>
          <div id="userDetailContent"><span class="empty">Loading...</span></div>
        </div>
      </div>

      <!-- Attack Pattern Preview -->
      <div class="card" style="grid-column:1/-1">
        <h2>Attack Pattern Preview</h2>
        <div style="display:flex;gap:12px;margin-bottom:16px;flex-wrap:wrap">
          <button class="btn btn-sm" onclick="showPreview('all')" style="background:#ffd700;color:#000">ALL</button>
          <button class="btn btn-sm" onclick="showPreview('NVIDIA')" style="background:#76b900;color:#000">NVIDIA (spray)</button>
          <button class="btn btn-sm" onclick="showPreview('Apple')" style="background:#a2aaad;color:#000">Apple (sniper)</button>
          <button class="btn btn-sm" onclick="showPreview('TSMC')" style="background:#c4001a;color:#fff">TSMC (drone)</button>
          <button class="btn btn-sm" onclick="showPreview('Google')" style="background:#4285f4;color:#fff">Google (pulse)</button>
          <button class="btn btn-sm" onclick="showPreview('META')" style="background:#0668e1;color:#fff">META (twin)</button>
          <span style="border-left:1px solid #2a3a4e;margin:0 4px"></span>
          <button class="btn btn-sm" onclick="showPreview('resistor')" style="background:#a0aec0;color:#000">Resistor</button>
          <button class="btn btn-sm" onclick="showPreview('capacitor')" style="background:#fbbf24;color:#000">Capacitor</button>
          <button class="btn btn-sm" onclick="showPreview('repeater')" style="background:#34d399;color:#000">Repeater</button>
          <button class="btn btn-sm" onclick="showPreview('inductor')" style="background:#a855f7;color:#fff">Inductor</button>
          <button class="btn btn-sm" onclick="showPreview('transformer')" style="background:#10b981;color:#000">Transformer</button>
          <button class="btn btn-sm" onclick="showPreview('oscillator')" style="background:#06b6d4;color:#000">Oscillator</button>
          <button class="btn btn-sm" onclick="showPreview('amplifier')" style="background:#ef4444;color:#fff">Amplifier</button>
        </div>
        <canvas id="previewCanvas" width="1200" height="600" style="width:100%;background:#0d1117;border:1px solid #2a3a4e;border-radius:4px"></canvas>
        <div id="previewInfo" style="margin-top:8px;font-size:0.8rem;color:#6b7a8d"></div>
      </div>

      <!-- Battle Test Mode -->
      <div class="card" style="grid-column:1/-1">
        <h2>Battle Test Mode</h2>
        <div id="battleNotLoaded" style="color:#6b7a8d;font-size:0.8rem">Loading balance data...</div>
        <div id="battleContainer" style="display:none">
          <div class="battle-layout">
            <!-- Setup Panel -->
            <div class="battle-setup">
              <div class="battle-group">
                <div class="group-title">Player (Left)</div>
                <select id="btPlayerClass" onchange="btUpdateInfo()">
                  <option value="resistor">Resistor (Tier 1)</option>
                  <option value="capacitor">Capacitor (Tier 2)</option>
                  <option value="repeater">Repeater (Tier 2)</option>
                  <option value="inductor">Inductor (Tier 3)</option>
                  <option value="transformer">Transformer (Tier 3)</option>
                  <option value="oscillator">Oscillator (Tier 3)</option>
                  <option value="amplifier">Amplifier (Tier 3)</option>
                </select>
                <div class="level-row">
                  <input type="range" id="btPlayerLevel" min="1" max="20" value="1" oninput="btUpdateInfo()">
                  <span id="btPlayerLevelLabel">Lv.1</span>
                </div>
                <div class="battle-entity-info" id="btPlayerInfo"></div>
              </div>
              <div class="battle-group">
                <div class="group-title">Enemy (Right)</div>
                <select id="btEnemyCategory" onchange="btUpdateEnemyOptions()">
                  <option value="class">Player Class</option>
                  <option value="boss">Boss</option>
                  <option value="neutral">Neutral Mob</option>
                  <option value="cell">Cell Turret</option>
                  <option value="minion">Minion</option>
                </select>
                <select id="btEnemyType" onchange="btUpdateInfo()"></select>
                <div id="btEnemyLevelWrap" class="level-row">
                  <input type="range" id="btEnemyLevel" min="1" max="20" value="1" oninput="btUpdateInfo()">
                  <span id="btEnemyLevelLabel">Lv.1</span>
                </div>
                <div class="battle-entity-info" id="btEnemyInfo"></div>
              </div>
              <div class="battle-controls">
                <button class="btn btn-primary btn-sm" id="btStartBtn" onclick="btStart()">START</button>
                <button class="btn btn-sm" style="background:#2a3a4e;color:#e0e6ed" id="btPauseBtn" onclick="btPause()" disabled>PAUSE</button>
                <button class="btn btn-danger btn-sm" id="btResetBtn" onclick="btReset()">RESET</button>
              </div>
              <div class="battle-results" id="btResults">
                <div class="battle-stat"><span class="bstat-val" id="btStatPlayerDps">-</span><span class="bstat-label">Player DPS</span></div>
                <div class="battle-stat"><span class="bstat-val" id="btStatEnemyDps">-</span><span class="bstat-label">Enemy DPS</span></div>
                <div class="battle-stat"><span class="bstat-val" id="btStatTtk">-</span><span class="bstat-label">TTK</span></div>
                <div class="battle-stat"><span class="bstat-val" id="btStatTime">0.0s</span><span class="bstat-label">Elapsed</span></div>
                <div class="battle-stat" id="btStatWinnerCard" style="grid-column:1/-1"><span class="bstat-val" id="btStatWinner">-</span><span class="bstat-label">Winner</span></div>
              </div>
            </div>
            <!-- Canvas -->
            <div class="battle-canvas-wrap">
              <canvas id="battleCanvas" width="900" height="450" style="width:100%;background:#0d1117;border:1px solid #2a3a4e;border-radius:4px"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let adminPassword = '';
    let refreshTimer = null;

    function authenticate() {
      adminPassword = document.getElementById('passwordInput').value;
      fetch('/api/admin/events', {
        headers: { 'X-Admin-Password': adminPassword },
      })
      .then(r => {
        if (r.status === 401) throw new Error('Wrong password');
        return r.json();
      })
      .then(() => {
        document.getElementById('authPanel').style.display = 'none';
        document.getElementById('mainPanel').style.display = 'block';
        updateDynamicFields();
        refreshAll();
        refreshTimer = setInterval(refreshAll, 5000);
      })
      .catch(err => {
        document.getElementById('authError').textContent = err.message;
      });
    }

    document.getElementById('passwordInput').addEventListener('keydown', e => {
      if (e.key === 'Enter') authenticate();
    });

    function api(method, path, body) {
      const opts = {
        method,
        headers: {
          'X-Admin-Password': adminPassword,
          'Content-Type': 'application/json',
        },
      };
      if (body) opts.body = JSON.stringify(body);
      return fetch(path, opts).then(r => r.json());
    }

    function refreshAll() {
      refreshGameStatus();
      refreshDailyRecords();
      refreshMarketStatus();
      refreshProviderStatus();
      refreshComplianceCheck();
      refreshNewsManagement();
      refreshEvents();
      refreshChat();
      refreshUserStats();
      searchUsers();
    }

    // Daily Records
    function refreshDailyRecords() {
      api('GET', '/api/admin/daily-records').then(data => {
        const el = document.getElementById('dailyRecordsList');
        const countEl = document.getElementById('dailyRecordsCount');
        const records = data.records || [];
        countEl.textContent = `${records.length} players`;
        if (records.length === 0) {
          el.innerHTML = '<span class="empty">No records today</span>';
          return;
        }
        el.innerHTML = records.map(r => {
          const teamColor = r.team === 'samsung' ? '#5a9bff' : '#ff6b80';
          const rankColor = r.rank <= 3 ? (r.rank === 1 ? '#ffd700' : r.rank === 2 ? '#c8c8c8' : '#cd7f32') : '#6b7a8d';
          const bg = r.rank === 1 ? 'rgba(255,215,0,0.06)' : r.rank === 2 ? 'rgba(200,200,200,0.04)' : r.rank === 3 ? 'rgba(205,127,50,0.04)' : 'rgba(10,10,20,0.4)';
          return `<div style="display:flex;justify-content:space-between;align-items:center;padding:3px 6px;background:${bg};border-radius:3px;font-size:0.8rem">
            <span style="color:${rankColor};width:24px;font-weight:${r.rank<=3?'bold':'normal'}">#${r.rank}</span>
            <span style="color:${teamColor};flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(r.name)}</span>
            <span style="color:#6b7a8d;width:20px;text-align:center;font-size:0.7rem">${(r.className || '').charAt(0).toUpperCase()}</span>
            <span style="color:#e0e6ed;width:50px;text-align:right">${r.score}</span>
            <span style="color:#ff6b6b;width:30px;text-align:right">${r.kills}K</span>
          </div>`;
        }).join('');
      }).catch(() => {});
    }

    // Market Status
    function refreshMarketStatus() {
      api('GET', '/api/admin/market-status').then(data => {
        const el = document.getElementById('marketStatus');
        if (data.error) { el.innerHTML = `<span class="empty">${data.error}</span>`; return; }
        const isOpen = data.isMarketOpen;
        const badge = isOpen ? '<span class="badge open">OPEN</span>' : '<span class="badge closed">CLOSED</span>';
        const provider = data.providerStatus;
        const qCache = data.quotesCache;
        const nCache = data.newsCache;
        el.innerHTML = `
          <div class="status-row"><span class="status-label">Market</span>${badge}</div>
          <div class="status-row"><span class="status-label">Poll Interval</span><span>${(data.currentPollInterval / 1000).toFixed(0)}s</span></div>
          <div class="status-row"><span class="status-label">Quote Cache</span><span>${qCache.hasData ? 'OK' : 'Empty'} (${(qCache.cacheAge / 1000).toFixed(0)}s ago)</span></div>
          <div class="status-row"><span class="status-label">News Cache</span><span>${nCache.count} items (${(nCache.cacheAge / 1000).toFixed(0)}s ago)</span></div>
          <div class="status-row"><span class="status-label">Active Provider</span><span>${provider.activeProvider || 'N/A'}</span></div>
        `;
      }).catch(() => {});
    }

    // Provider Status
    function refreshProviderStatus() {
      api('GET', '/api/admin/market-status').then(data => {
        const el = document.getElementById('providerStatus');
        if (data.error) { el.innerHTML = `<span class="empty">${data.error}</span>`; return; }
        const ps = data.providerStatus;
        if (!ps || !ps.providers) {
          el.innerHTML = '<span class="empty">No provider data</span>';
          return;
        }
        el.innerHTML = ps.providers.map(p => {
          const statusBadge = p.healthy
            ? '<span class="badge open">HEALTHY</span>'
            : '<span class="badge cancelled">FAILED</span>';
          const failures = p.failures > 0 ? ` (${p.failures} failures)` : '';
          return `<div class="status-row">
            <span class="status-label">${esc(p.name)}</span>
            <span>${statusBadge}${failures}</span>
          </div>`;
        }).join('');
        if (ps.activeProvider) {
          el.innerHTML += `<div class="status-row" style="margin-top:6px;border-top:1px solid #2a3a4e;padding-top:4px">
            <span class="status-label">Active</span>
            <span style="color:#22c55e;font-weight:700">${esc(ps.activeProvider)}</span>
          </div>`;
        }
      }).catch(() => {});
    }

    // Compliance Check
    function refreshComplianceCheck() {
      api('GET', '/api/admin/market-status').then(data => {
        const el = document.getElementById('complianceCheck');
        if (data.error) { el.innerHTML = `<span class="empty">${data.error}</span>`; return; }
        const flags = data.featureFlags || {};
        const mockMode = flags.USE_MOCK_MARKET_DATA;
        const liveBuff = flags.ENABLE_LIVE_MARKET_BUFFS;
        const newsEvents = flags.ENABLE_NEWS_EVENTS;

        const check = (ok, label) => `<span style="color:${ok ? '#22c55e' : '#f59e0b'}">${ok ? 'PASS' : 'WARN'}</span> ${label}`;

        el.innerHTML = `
          <div class="status-row">
            <span class="status-label">Mock Mode</span>
            <span class="badge ${mockMode ? 'active' : 'closed'}">${mockMode ? 'ON (safe)' : 'OFF (live)'}</span>
          </div>
          <div class="status-row">
            <span class="status-label">Live Buffs</span>
            <span class="badge ${liveBuff ? 'active' : 'closed'}">${liveBuff ? 'ENABLED' : 'DISABLED'}</span>
          </div>
          <div class="status-row">
            <span class="status-label">News Events</span>
            <span class="badge ${newsEvents ? 'active' : 'closed'}">${newsEvents ? 'ENABLED' : 'DISABLED'}</span>
          </div>
          <div class="status-row">
            <span class="status-label">Data Delay</span>
            <span>${check(true, '15min+ delayed (enforced by design)')}</span>
          </div>
          <div class="status-row">
            <span class="status-label">Disclaimer</span>
            <span>${check(true, 'KO + EN footer present')}</span>
          </div>
          <div class="status-row">
            <span class="status-label">Buff Cap</span>
            <span>${check(true, 'DMG cap: +-10%, SPD cap: +-5%')}</span>
          </div>
        `;
      }).catch(() => {});
    }

    // Game Status
    function refreshGameStatus() {
      api('GET', '/api/admin/game-status').then(data => {
        const el = document.getElementById('gameStatus');
        const running = data.running;
        const mapId = data.mapId || 'N/A';
        const mapLabel = mapId === 'map_tribus_circuit' ? 'Tri-Bus Circuit'
          : mapId === 'map_wafer_ring' ? 'Wafer Ring Arena' : mapId;
        el.innerHTML = `
          <div class="status-row"><span class="status-label">Status</span><span class="badge ${running ? 'open' : 'closed'}">${running ? 'RUNNING' : 'IDLE'}</span></div>
          <div class="status-row"><span class="status-label">Current Map</span><span>${esc(mapLabel)}</span></div>
          <div class="status-row"><span class="status-label">Players</span><span>${data.players || 0}</span></div>
          <div class="status-row"><span class="status-label">Bots</span><span>${data.bots || 0}</span></div>
        `;
        // Highlight active map button
        const tribusBtn = document.getElementById('mapBtn_tribus');
        const waferBtn = document.getElementById('mapBtn_wafer');
        tribusBtn.classList.toggle('active', mapId === 'map_tribus_circuit');
        waferBtn.classList.toggle('active', mapId === 'map_wafer_ring');
      }).catch(() => {});
    }

    function changeMap(mapId) {
      const mapLabel = mapId === 'map_tribus_circuit' ? 'Tri-Bus Circuit' : 'Wafer Ring Arena';
      if (!confirm(`맵을 "${mapLabel}"(으)로 변경하시겠습니까?\n현재 진행 중인 게임이 리셋됩니다.`)) return;
      api('POST', '/api/admin/change-map', { mapId }).then(data => {
        if (data.ok) {
          refreshGameStatus();
        } else {
          alert('Map change failed: ' + (data.error || 'Unknown error'));
        }
      }).catch(err => alert('Map change error: ' + err.message));
    }

    // News Management
    function refreshNewsManagement() {
      api('GET', '/api/admin/news').then(data => {
        // Custom news
        const customEl = document.getElementById('customNewsList');
        const custom = data.custom || [];
        if (custom.length === 0) {
          customEl.innerHTML = '<span class="empty">No custom news</span>';
        } else {
          customEl.innerHTML = custom.map(n => {
            const time = new Date(n.createdAt).toLocaleTimeString('ko-KR');
            return `<div class="news-custom-item">
              <div>
                <span class="news-corp">[${esc(n.corpName)}]</span>
                ${esc(n.title)}
                <span style="color:#4a5568;font-size:0.7rem;margin-left:8px">${time}</span>
              </div>
              <button class="btn btn-danger btn-sm" onclick="deleteNews(${n.id})">DEL</button>
            </div>`;
          }).join('');
        }
        // Provider news
        const providerEl = document.getElementById('providerNewsList');
        const provider = data.provider || [];
        if (provider.length === 0) {
          providerEl.innerHTML = '<span class="empty">No provider news</span>';
        } else {
          providerEl.innerHTML = provider.slice(0, 10).map(n => {
            const corp = n.corpName ? `<span class="news-corp">[${esc(n.corpName)}]</span> ` : '';
            return `<div class="news-item">${corp}${esc(n.title)}</div>`;
          }).join('');
        }
      }).catch(() => {});
    }

    function addNews() {
      const title = document.getElementById('newsTitle').value.trim();
      if (!title) { document.getElementById('newsResult').innerHTML = '<span class="result-err">제목을 입력하세요</span>'; return; }
      const corpName = document.getElementById('newsCorpName').value;
      const team = document.getElementById('newsTeam').value;
      const type = document.getElementById('newsType').value;
      api('POST', '/api/admin/news', { title, corpName, team, type }).then(data => {
        const el = document.getElementById('newsResult');
        if (data.ok) {
          el.innerHTML = '<span class="result-ok">News added</span>';
          document.getElementById('newsTitle').value = '';
          refreshNewsManagement();
        } else {
          el.innerHTML = `<span class="result-err">${esc(data.error)}</span>`;
        }
        setTimeout(() => { el.innerHTML = ''; }, 3000);
      }).catch(err => {
        document.getElementById('newsResult').innerHTML = `<span class="result-err">${err.message}</span>`;
      });
    }

    function deleteNews(id) {
      api('DELETE', `/api/admin/news/${id}`).then(data => {
        if (data.ok) refreshNewsManagement();
      });
    }

    // Events
    function refreshEvents() {
      api('GET', '/api/admin/events').then(data => {
        // Active
        const activeEl = document.getElementById('activeEvents');
        const active = data.active || [];
        if (active.length === 0) {
          activeEl.innerHTML = '<span class="empty">No active events</span>';
        } else {
          activeEl.innerHTML = active.map(e => {
            const remaining = Math.max(0, Math.ceil((e.expiresAt - Date.now()) / 1000));
            return `<div class="event-item">
              <div>
                <span class="badge active">${e.type}</span> ${esc(e.title)}
                <div class="event-meta">${remaining}s remaining</div>
              </div>
              <button class="btn btn-danger btn-sm" onclick="cancelEvent('${e.id}')">CANCEL</button>
            </div>`;
          }).join('');
        }
        // Recent
        const recentEl = document.getElementById('recentEvents');
        const recent = data.recent || [];
        if (recent.length === 0) {
          recentEl.innerHTML = '<span class="empty">No recent events</span>';
        } else {
          recentEl.innerHTML = recent.map(e => {
            const badgeClass = e.status === 'expired' ? 'expired' : e.status === 'cancelled' ? 'cancelled' : 'active';
            const time = new Date(e.createdAt).toLocaleTimeString('ko-KR');
            return `<div class="event-item">
              <div>
                <span class="badge ${badgeClass}">${e.status}</span> ${esc(e.type)}: ${esc(e.title)}
                <div class="event-meta">${time}</div>
              </div>
            </div>`;
          }).join('');
        }
      }).catch(() => {});
    }

    function cancelEvent(id) {
      api('DELETE', `/api/admin/event/${id}`).then(data => {
        if (data.ok) refreshEvents();
      });
    }

    // Dynamic form fields per event type
    function updateDynamicFields() {
      const type = document.getElementById('eventType').value;
      const container = document.getElementById('dynamicFields');
      let html = '';

      if (type === 'BOSS_SPAWN') {
        html = `
          <div class="form-row">
            <div class="form-group">
              <label>Monster Type</label>
              <select id="param_monsterType">
                <option value="NVIDIA">NVIDIA (DMG+30%)</option>
                <option value="Apple">Apple (SPD+25%)</option>
                <option value="TSMC">TSMC (DMG+50%)</option>
                <option value="Google">Google (HP REGEN)</option>
                <option value="META">META (ARMOR+20%)</option>
              </select>
            </div>
            <div class="form-group">
              <label>HP Multiplier</label>
              <input type="number" id="param_hpMultiplier" value="1.5" min="0.5" max="3" step="0.1">
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label>Position X</label>
              <input type="number" id="param_posX" value="1200" min="0">
            </div>
            <div class="form-group">
              <label>Position Y</label>
              <input type="number" id="param_posY" value="800" min="0">
            </div>
          </div>`;
      } else if (type === 'ZONE_MODIFIER') {
        html = `
          <div class="form-row">
            <div class="form-group">
              <label>Effect</label>
              <select id="param_effect">
                <option value="damage_boost">Damage Boost</option>
                <option value="speed_boost">Speed Boost</option>
                <option value="heal_zone">Heal Zone</option>
                <option value="slow_zone">Slow Zone</option>
              </select>
            </div>
            <div class="form-group">
              <label>Value (0.05~0.25)</label>
              <input type="number" id="param_value" value="0.15" min="0.05" max="0.25" step="0.01">
            </div>
            <div class="form-group">
              <label>Radius</label>
              <input type="number" id="param_radius" value="200" min="100" max="400">
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label>Position X</label>
              <input type="number" id="param_posX" value="1200" min="0">
            </div>
            <div class="form-group">
              <label>Position Y</label>
              <input type="number" id="param_posY" value="800" min="0">
            </div>
            <div class="form-group">
              <label>Affects Team</label>
              <select id="param_affectsTeam">
                <option value="all">All</option>
                <option value="samsung">Samsung</option>
                <option value="skhynix">SK Hynix</option>
              </select>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label>Visual Color</label>
              <input type="color" id="param_visualColor" value="#76b900">
            </div>
            <div class="form-group">
              <label>Custom Label</label>
              <input type="text" id="param_customLabel" placeholder="Zone label">
            </div>
          </div>`;
      } else if (type === 'GLOBAL_PARAM') {
        html = `
          <div class="form-row">
            <div class="form-group">
              <label>Parameter</label>
              <select id="param_parameter">
                <option value="minionSpawnRate">Minion Spawn Rate</option>
                <option value="minionSpawnCount">Minion Spawn Count</option>
                <option value="pickupSpawnRate">Pickup Spawn Rate</option>
                <option value="monsterHpScale">Monster HP Scale</option>
                <option value="respawnDelay">Respawn Delay</option>
                <option value="cellCaptureSpeed">Cell Capture Speed</option>
              </select>
            </div>
            <div class="form-group">
              <label>Multiplier (0.5~3.0)</label>
              <input type="number" id="param_multiplier" value="1.5" min="0.5" max="3" step="0.1">
            </div>
          </div>`;
      } else if (type === 'NEWS_TICKER') {
        html = `
          <div class="form-row">
            <div class="form-group">
              <label>Headline</label>
              <input type="text" id="param_headline" placeholder="English headline">
            </div>
            <div class="form-group">
              <label>Headline (KO)</label>
              <input type="text" id="param_headlineKo" placeholder="Korean headline">
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label>Importance</label>
              <select id="param_importance">
                <option value="low">Low</option>
                <option value="medium" selected>Medium</option>
                <option value="high">High</option>
              </select>
            </div>
            <div class="form-group">
              <label>Team</label>
              <select id="param_team">
                <option value="">None</option>
                <option value="samsung">Samsung</option>
                <option value="skhynix">SK Hynix</option>
              </select>
            </div>
          </div>`;
      }

      container.innerHTML = html;
    }

    function createEvent() {
      const type = document.getElementById('eventType').value;
      const title = document.getElementById('eventTitle').value || type;
      const duration = parseInt(document.getElementById('eventDuration').value) || 60000;

      const params = {};

      if (type === 'BOSS_SPAWN') {
        params.monsterType = val('param_monsterType');
        params.hpMultiplier = parseFloat(val('param_hpMultiplier')) || 1;
        params.position = { x: parseInt(val('param_posX')) || 1200, y: parseInt(val('param_posY')) || 800 };
      } else if (type === 'ZONE_MODIFIER') {
        params.effect = val('param_effect');
        params.value = parseFloat(val('param_value')) || 0.15;
        params.radius = parseInt(val('param_radius')) || 200;
        params.position = { x: parseInt(val('param_posX')) || 1200, y: parseInt(val('param_posY')) || 800 };
        params.affectsTeam = val('param_affectsTeam') || 'all';
        params.visualColor = val('param_visualColor') || '#76b900';
        params.customLabel = val('param_customLabel') || '';
      } else if (type === 'GLOBAL_PARAM') {
        params.parameter = val('param_parameter');
        params.multiplier = parseFloat(val('param_multiplier')) || 1.5;
      } else if (type === 'NEWS_TICKER') {
        params.headline = val('param_headline') || '';
        params.headlineKo = val('param_headlineKo') || '';
        params.importance = val('param_importance') || 'medium';
        params.team = val('param_team') || null;
      }

      const body = { type, title, duration, params };

      api('POST', '/api/admin/event', body).then(data => {
        const el = document.getElementById('eventResult');
        if (data.ok) {
          el.innerHTML = `<span class="result-ok">Event created: ${esc(data.event.id)}</span>`;
          refreshEvents();
        } else {
          el.innerHTML = `<span class="result-err">${esc(data.error)}${data.details ? ': ' + esc(data.details) : ''}</span>`;
        }
        setTimeout(() => { el.innerHTML = ''; }, 5000);
      }).catch(err => {
        document.getElementById('eventResult').innerHTML = `<span class="result-err">${err.message}</span>`;
      });
    }

    // Chat Management
    function refreshChat() {
      api('GET', '/api/admin/chat').then(data => {
        const el = document.getElementById('chatList');
        const countEl = document.getElementById('chatCount');
        const msgs = data.messages || [];
        countEl.textContent = `${data.total || 0} messages`;
        if (msgs.length === 0) {
          el.innerHTML = '<span class="empty">No chat messages</span>';
          return;
        }
        el.innerHTML = msgs.map(m => {
          const time = new Date(m.ts).toLocaleString('ko-KR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
          if (m.type === 'system') {
            return `<div class="chat-item">
              <div><span class="chat-meta">${time}</span> <span class="chat-system">[SYSTEM] ${esc(m.message)}</span></div>
              <button class="btn btn-danger btn-sm" onclick="deleteChat(${m.id})">DEL</button>
            </div>`;
          }
          const teamClass = m.team === 'samsung' ? 'chat-team-sam' : 'chat-team-skh';
          const teamLabel = m.team === 'samsung' ? 'SAM' : 'SKH';
          return `<div class="chat-item">
            <div><span class="chat-meta">${time}</span> <span class="${teamClass}">[${teamLabel}]</span> <strong>${esc(m.nickname)}</strong>: ${esc(m.message)}</div>
            <button class="btn btn-danger btn-sm" onclick="deleteChat(${m.id})">DEL</button>
          </div>`;
        }).join('');
      }).catch(() => {});
    }

    function deleteChat(id) {
      api('DELETE', `/api/admin/chat/${id}`).then(data => {
        if (data.ok) refreshChat();
      });
    }

    function clearAllChat() {
      if (!confirm('전체 채팅 기록을 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.')) return;
      api('DELETE', '/api/admin/chat').then(data => {
        if (data.ok) refreshChat();
      });
    }

    function val(id) {
      const el = document.getElementById(id);
      return el ? el.value : '';
    }

    function esc(str) {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // ── User Management ──
    let currentUserPage = 1;

    function formatPlaytime(ms) {
      if (!ms || ms <= 0) return '0s';
      const s = Math.floor(ms / 1000);
      if (s < 60) return s + 's';
      const m = Math.floor(s / 60);
      if (m < 60) return m + 'm ' + (s % 60) + 's';
      const h = Math.floor(m / 60);
      return h + 'h ' + (m % 60) + 'm';
    }

    function formatDate(ts) {
      if (!ts) return '-';
      return new Date(ts).toLocaleString('ko-KR', {
        month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit',
      });
    }

    function refreshUserStats() {
      api('GET', '/api/admin/users-stats').then(data => {
        document.getElementById('statTotalUsers').textContent = data.totalUsers || 0;
        document.getElementById('statTodayActive').textContent = data.todayActive || 0;
        document.getElementById('statOnlineNow').textContent = data.onlineNow || 0;
        document.getElementById('statTotalSessions').textContent = data.totalSessions || 0;
        document.getElementById('statAvgPlaytime').textContent = formatPlaytime(data.avgPlaytimeMs || 0);
      }).catch(() => {});
    }

    function searchUsers(page) {
      if (page) currentUserPage = page;
      else if (!page) currentUserPage = currentUserPage || 1;

      const q = (document.getElementById('userSearchInput') || {}).value || '';
      const sort = (document.getElementById('userSortSelect') || {}).value || 'lastSeen';
      const limit = 15;

      api('GET', `/api/admin/users?q=${encodeURIComponent(q)}&sort=${sort}&page=${currentUserPage}&limit=${limit}`).then(data => {
        const tbody = document.getElementById('userTableBody');
        const users = data.users || [];

        if (users.length === 0) {
          tbody.innerHTML = '<tr><td colspan="8" class="empty">No users found</td></tr>';
        } else {
          tbody.innerHTML = users.map(u => {
            const uuidShort = u.uuid.length > 12 ? u.uuid.slice(0, 8) + '...' : u.uuid;
            const nicks = (u.nicknames || []).slice(-3).join(', ');
            const teamBadge = u.lastTeam === 'samsung'
              ? '<span style="color:#5a9bff">SAM</span>'
              : u.lastTeam === 'skhynix'
                ? '<span style="color:#ff6b80">SKH</span>'
                : '<span style="color:#6b7a8d">-</span>';
            const pt = formatPlaytime(u.totalPlaytimeMs);
            const ls = formatDate(u.lastSeen);

            return `<tr>
              <td><span class="uuid-short" title="${esc(u.uuid)}">${esc(uuidShort)}</span></td>
              <td><span class="nick-list">${esc(nicks)}</span></td>
              <td>${teamBadge}</td>
              <td>${u.visitCount || 0}</td>
              <td>${u.totalScore || 0}</td>
              <td>${pt}</td>
              <td>${ls}</td>
              <td><button class="btn btn-sm" style="background:#2a3a4e;color:#e0e6ed" onclick="showUserDetail('${esc(u.uuid)}')">DETAIL</button></td>
            </tr>`;
          }).join('');
        }

        // 페이지네이션
        const pag = document.getElementById('userPagination');
        const total = data.total || 0;
        const totalPages = data.totalPages || 1;
        pag.innerHTML = `
          <button ${currentUserPage <= 1 ? 'disabled' : ''} onclick="searchUsers(${currentUserPage - 1})">PREV</button>
          <span class="page-info">${currentUserPage} / ${totalPages} (${total} users)</span>
          <button ${currentUserPage >= totalPages ? 'disabled' : ''} onclick="searchUsers(${currentUserPage + 1})">NEXT</button>
        `;
      }).catch(() => {});
    }

    function showUserDetail(uuid) {
      const modal = document.getElementById('userDetailModal');
      const content = document.getElementById('userDetailContent');
      content.innerHTML = '<span class="empty">Loading...</span>';
      modal.classList.add('show');

      api('GET', `/api/admin/users/${encodeURIComponent(uuid)}`).then(u => {
        if (u.error) { content.innerHTML = `<span class="empty">${esc(u.error)}</span>`; return; }

        const kdRatio = u.totalDeaths > 0 ? (u.totalKills / u.totalDeaths).toFixed(2) : u.totalKills.toFixed(2);
        const allNicks = (u.nicknames || []).join(', ');

        let sessionsHtml = '';
        if (u.sessions && u.sessions.length > 0) {
          const rows = u.sessions.slice().reverse().map(s => {
            const joined = formatDate(s.joinedAt);
            const left = formatDate(s.leftAt);
            const pt = formatPlaytime(s.playtimeMs);
            const teamBadge = s.team === 'samsung'
              ? '<span style="color:#5a9bff">SAM</span>'
              : '<span style="color:#ff6b80">SKH</span>';
            return `<tr>
              <td>${joined}</td>
              <td>${left}</td>
              <td>${pt}</td>
              <td>${esc(s.nickname)}</td>
              <td>${teamBadge}</td>
              <td>${esc(s.mapId || '-')}</td>
              <td>${s.kills}/${s.deaths}</td>
              <td>Lv.${s.level} ${esc(s.className)}</td>
            </tr>`;
          }).join('');

          sessionsHtml = `
            <div class="section-label" style="margin-top:16px">Session History (${u.sessions.length})</div>
            <div style="overflow-x:auto">
              <table class="session-table">
                <thead><tr>
                  <th>Joined</th><th>Left</th><th>Time</th><th>Nick</th><th>Team</th><th>Map</th><th>K/D</th><th>Class</th>
                </tr></thead>
                <tbody>${rows}</tbody>
              </table>
            </div>
          `;
        }

        content.innerHTML = `
          <div class="detail-row"><span class="status-label">UUID</span><span style="font-size:0.75rem;word-break:break-all">${esc(u.uuid)}</span></div>
          <div class="detail-row"><span class="status-label">Nicknames</span><span>${esc(allNicks)}</span></div>
          <div class="detail-row"><span class="status-label">Last Team</span><span>${u.lastTeam === 'samsung' ? '<span style="color:#5a9bff">Samsung</span>' : '<span style="color:#ff6b80">SK Hynix</span>'}</span></div>
          <div class="detail-row"><span class="status-label">Visit Count</span><span>${u.visitCount}</span></div>
          <div class="detail-row"><span class="status-label">Total Kills</span><span>${u.totalKills}</span></div>
          <div class="detail-row"><span class="status-label">Total Deaths</span><span>${u.totalDeaths}</span></div>
          <div class="detail-row"><span class="status-label">K/D Ratio</span><span>${kdRatio}</span></div>
          <div class="detail-row"><span class="status-label">Total Score</span><span>${u.totalScore}</span></div>
          <div class="detail-row"><span class="status-label">Total Playtime</span><span>${formatPlaytime(u.totalPlaytimeMs)}</span></div>
          <div class="detail-row"><span class="status-label">First Seen</span><span>${formatDate(u.firstSeen)}</span></div>
          <div class="detail-row"><span class="status-label">Last Seen</span><span>${formatDate(u.lastSeen)}</span></div>
          ${sessionsHtml}
        `;
      }).catch(err => {
        content.innerHTML = `<span class="empty">Error: ${err.message}</span>`;
      });
    }

    function closeUserDetail() {
      document.getElementById('userDetailModal').classList.remove('show');
    }

    // ESC로 모달 닫기
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') closeUserDetail();
    });

    // ── Attack Pattern Preview ──
    const BOSSES = [
      { name:'NVIDIA', style:'spray', color:'#76b900', dmg:12, cd:1800, bullets:3, spread:0.4, hp:500, buff:'DMG +30%' },
      { name:'Apple', style:'sniper', color:'#a2aaad', dmg:30, cd:2500, bulletSpeed:500, hp:400, buff:'SPD +25%' },
      { name:'TSMC', style:'drone', color:'#c4001a', dmg:8, cd:3000, maxDrones:4, hp:600, buff:'DMG +50%' },
      { name:'Google', style:'pulse', color:'#4285f4', dmg:20, cd:3500, pulseR:200, hp:550, buff:'HP REGEN' },
      { name:'META', style:'twin', color:'#0668e1', dmg:10, cd:1200, hp:450, buff:'ARMOR +20%' },
    ];
    const CLASSES = [
      { name:'resistor', color:'#a0aec0', style:'single', dmg:10, cd:350, range:280, speed:500, hp:120, tier:1, desc:'Single shot projectile' },
      { name:'capacitor', color:'#fbbf24', style:'orbit', dmg:18, cd:0, range:90, orbCount:3, hp:250, shield:80, tier:2, desc:'3 orbital orbs + shield' },
      { name:'repeater', color:'#34d399', style:'single', dmg:7, cd:150, range:280, speed:700, hp:110, tier:2, desc:'Fast single shots (CD 150ms)' },
      { name:'inductor', color:'#a855f7', style:'orbit', dmg:17, cd:0, range:110, orbCount:4, hp:280, shield:60, tier:3, magneticPull:true, desc:'4 orbs + magnetic pull' },
      { name:'transformer', color:'#10b981', style:'orbit', dmg:15, cd:0, range:80, orbCount:3, hp:300, shield:100, tier:3, aura:true, desc:'3 orbs + aura (DMG+15%/regen)' },
      { name:'oscillator', color:'#06b6d4', style:'single', dmg:7, cd:200, range:280, speed:700, hp:130, tier:3, multiShot:3, desc:'REPEATER + 3-way spread shots' },
      { name:'amplifier', color:'#ef4444', style:'single', dmg:7, cd:200, range:400, speed:800, hp:130, tier:3, ampedEvery:4, desc:'REPEATER + amped every 4th shot' },
    ];

    let previewAnim = null;
    let previewFilter = 'all';

    function showPreview(filter) {
      previewFilter = filter;
      if (previewAnim) cancelAnimationFrame(previewAnim);
      runPreview();
    }

    function runPreview() {
      const cvs = document.getElementById('previewCanvas');
      if (!cvs) return;
      const ctx = cvs.getContext('2d');
      const W = cvs.width, H = cvs.height;

      // 표시할 엔티티 결정
      let entities = [];
      const isBoss = BOSSES.find(b => b.name === previewFilter);
      const isClass = CLASSES.find(c => c.name === previewFilter);
      if (isBoss) entities = [{ type:'boss', data:isBoss }];
      else if (isClass) entities = [{ type:'class', data:isClass }];
      else {
        // all
        BOSSES.forEach(b => entities.push({ type:'boss', data:b }));
        CLASSES.forEach(c => entities.push({ type:'class', data:c }));
      }

      // 엔티티별 위치 할당
      const count = entities.length;
      const cols = Math.min(count, count <= 3 ? count : Math.ceil(count / 2));
      const rows = Math.ceil(count / cols);
      const cellW = W / cols, cellH = H / rows;
      entities.forEach((e, i) => {
        e.cx = (i % cols) * cellW + cellW / 2;
        e.cy = Math.floor(i / cols) * cellH + cellH / 2;
      });

      // 애니메이션 상태
      const bullets = [];
      const drones = [];
      const pulses = [];
      const orbitAngles = {};
      let lastTime = performance.now();
      const cooldowns = {};

      function frame(now) {
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;
        ctx.clearRect(0, 0, W, H);

        // 그리드
        ctx.strokeStyle = '#1a2030';
        ctx.lineWidth = 0.5;
        for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
        for (let y = 0; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

        // 총알 업데이트
        for (const b of bullets) {
          b.x += Math.cos(b.angle) * b.speed * dt;
          b.y += Math.sin(b.angle) * b.speed * dt;
          b.life -= dt;
        }
        bullets.splice(0, bullets.length, ...bullets.filter(b => b.life > 0 && b.x > 0 && b.x < W && b.y > 0 && b.y < H));

        // 드론 업데이트
        for (const d of drones) {
          d.angle += 1.5 * dt;
          d.x = d.cx + Math.cos(d.angle) * d.orbitR;
          d.y = d.cy + Math.sin(d.angle) * d.orbitR;
          d.life -= dt;
        }
        drones.splice(0, drones.length, ...drones.filter(d => d.life > 0));

        // 펄스 업데이트
        for (const p of pulses) { p.r += 300 * dt; p.alpha -= 1.5 * dt; }
        pulses.splice(0, pulses.length, ...pulses.filter(p => p.alpha > 0));

        const t = now / 1000;
        for (const e of entities) {
          const { cx, cy, type, data } = e;
          const key = data.name;
          if (!cooldowns[key]) cooldowns[key] = 0;
          cooldowns[key] -= dt * 1000;

          // 사거리 원
          ctx.globalAlpha = 0.08;
          ctx.fillStyle = data.color;
          ctx.beginPath();
          const rangeR = type === 'boss' ? 120 : (data.range || 90);
          ctx.arc(cx, cy, rangeR, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;

          if (type === 'boss') {
            const r = 28;
            ctx.save();
            ctx.translate(cx, cy);
            const aim = t * 0.8;
            ctx.rotate(aim);
            ctx.fillStyle = data.color;
            ctx.globalAlpha = 0.85;

            if (data.style === 'spray') {
              ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
              ctx.globalAlpha = 1;
              for (let i = -1; i <= 1; i++) { ctx.save(); ctx.rotate(i*0.4); ctx.fillRect(r*0.3,-3,r*0.8,6); ctx.restore(); }
            } else if (data.style === 'sniper') {
              ctx.beginPath(); ctx.arc(0, 0, r*0.85, 0, Math.PI*2); ctx.fill();
              ctx.globalAlpha = 1; ctx.fillRect(r*0.2,-4,r*1.2,8);
            } else if (data.style === 'drone') {
              const s = r*0.75; ctx.fillRect(-s,-s,s*2,s*2);
              ctx.globalAlpha = 0.5; ctx.fillStyle = '#fff'; ctx.fillRect(-s*0.4,-s*0.4,s*0.8,s*0.8);
            } else if (data.style === 'pulse') {
              ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
            } else if (data.style === 'twin') {
              ctx.beginPath(); ctx.arc(0, 0, r*0.85, 0, Math.PI*2); ctx.fill();
              ctx.globalAlpha = 1; ctx.fillRect(r*0.3,-9,r*0.7,6); ctx.fillRect(r*0.3,3,r*0.7,6);
            }
            ctx.restore();
            ctx.globalAlpha = 1;

            // 공격 시뮬레이션
            if (cooldowns[key] <= 0) {
              cooldowns[key] = data.cd;
              const a = t * 0.8;
              if (data.style === 'spray') {
                for (let i = -1; i <= 1; i++) bullets.push({ x:cx, y:cy, angle:a+i*data.spread, speed:300, life:1.5, color:data.color, r:5 });
              } else if (data.style === 'sniper') {
                bullets.push({ x:cx, y:cy, angle:a, speed:data.bulletSpeed||500, life:1.2, color:data.color, r:7 });
              } else if (data.style === 'drone') {
                if (drones.filter(d => d.color === data.color).length < data.maxDrones) {
                  drones.push({ cx, cy, x:cx, y:cy, angle:Math.random()*Math.PI*2, orbitR:50+Math.random()*30, life:4, color:data.color, r:8 });
                }
              } else if (data.style === 'pulse') {
                pulses.push({ x:cx, y:cy, r:0, maxR:data.pulseR||200, alpha:0.6, color:data.color });
              } else if (data.style === 'twin') {
                const perp = a + Math.PI/2;
                for (const s of [-1,1]) bullets.push({ x:cx+Math.cos(perp)*8*s, y:cy+Math.sin(perp)*8*s, angle:a, speed:300, life:1.5, color:data.color, r:5 });
              }
            }
          } else {
            // 클래스 캐릭터
            const r = 18;
            ctx.save(); ctx.translate(cx, cy);
            const aim = t * 0.6;

            if (data.style === 'orbit') {
              // orbit classes: capacitor / inductor / transformer
              ctx.fillStyle = data.color; ctx.globalAlpha = 0.85;
              ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
              // 보호막 링
              if (data.shield) {
                ctx.globalAlpha = 0.3; ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0, 0, r + 6, 0, Math.PI*2); ctx.stroke();
              }
              // Aura ring (Transformer)
              if (data.aura) {
                ctx.globalAlpha = 0.12; ctx.strokeStyle = data.color; ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI*2); ctx.stroke();
                ctx.setLineDash([]);
                // Aura glow
                ctx.globalAlpha = 0.06; ctx.fillStyle = data.color;
                ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI*2); ctx.fill();
              }
              // Magnetic pull indicator (Inductor)
              if (data.magneticPull) {
                ctx.globalAlpha = 0.15; ctx.strokeStyle = data.color; ctx.lineWidth = 1.5;
                for (let ring = 1; ring <= 3; ring++) {
                  const rr = 30 + ring * 15;
                  ctx.beginPath(); ctx.arc(0, 0, rr, -0.4 + t*2, 0.4 + t*2); ctx.stroke();
                  ctx.beginPath(); ctx.arc(0, 0, rr, Math.PI - 0.4 + t*2, Math.PI + 0.4 + t*2); ctx.stroke();
                }
              }
              // 오비탈
              ctx.globalAlpha = 1;
              if (!orbitAngles[key]) orbitAngles[key] = 0;
              const orbSpd = data.name === 'inductor' ? 2.2 : data.name === 'transformer' ? 3.0 : 2.8;
              orbitAngles[key] += orbSpd * dt;
              const orbCount = data.orbCount || 3;
              const orbR = data.range || 90;
              const orbSize = data.name === 'inductor' ? 10 : 8;
              for (let i = 0; i < orbCount; i++) {
                const oa = orbitAngles[key] + (Math.PI*2/orbCount)*i;
                const ox = Math.cos(oa) * orbR;
                const oy = Math.sin(oa) * orbR;
                ctx.fillStyle = data.color;
                ctx.beginPath(); ctx.arc(ox, oy, orbSize, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
              }
            } else {
              // single-shot classes: resistor / repeater / oscillator / amplifier
              ctx.rotate(aim);
              ctx.fillStyle = data.color; ctx.globalAlpha = 0.85;
              // Oscillator: wider triangle body
              if (data.name === 'oscillator') {
                ctx.beginPath(); ctx.moveTo(r*1.1, 0); ctx.lineTo(-r*0.6, -r*0.85); ctx.lineTo(-r*0.6, r*0.85); ctx.closePath(); ctx.fill();
                // side barrel indicators
                ctx.globalAlpha = 0.5;
                ctx.fillRect(r*0.2, r*0.4, r*0.5, 3);
                ctx.fillRect(r*0.2, -r*0.4-3, r*0.5, 3);
              } else if (data.name === 'amplifier') {
                // Amplifier: slightly bigger triangle + barrel
                ctx.beginPath(); ctx.moveTo(r*1.2, 0); ctx.lineTo(-r*0.7, -r*0.75); ctx.lineTo(-r*0.7, r*0.75); ctx.closePath(); ctx.fill();
                ctx.globalAlpha = 0.5;
                ctx.fillRect(r*0.3, -2.5, r*0.7, 5);
              } else {
                ctx.beginPath(); ctx.moveTo(r, 0); ctx.lineTo(-r*0.7, -r*0.7); ctx.lineTo(-r*0.7, r*0.7); ctx.closePath(); ctx.fill();
              }
              ctx.globalAlpha = 1;

              if (!cooldowns[key+'_shotCount']) cooldowns[key+'_shotCount'] = 0;
              if (cooldowns[key] <= 0) {
                cooldowns[key] = data.cd;
                cooldowns[key+'_shotCount']++;

                if (data.multiShot) {
                  // Oscillator: 3-way spread
                  const spread = 0.25;
                  for (let i = 0; i < data.multiShot; i++) {
                    const sa = aim + (i - (data.multiShot-1)/2) * spread;
                    bullets.push({ x:cx, y:cy, angle:sa, speed:data.speed||500, life:1.2, color:data.color, r:3 });
                  }
                } else if (data.ampedEvery && cooldowns[key+'_shotCount'] % data.ampedEvery === 0) {
                  // Amplifier: amped shot (bigger, brighter)
                  bullets.push({ x:cx, y:cy, angle:aim, speed:data.speed||500, life:1.2, color:'#fbbf24', r:7 });
                } else {
                  bullets.push({ x:cx, y:cy, angle:aim, speed:data.speed||500, life:1.2, color:data.color, r:4 });
                }
              }
            }
            ctx.restore();
            ctx.globalAlpha = 1;
          }

          // 라벨
          ctx.font = 'bold 11px Orbitron';
          ctx.fillStyle = data.color;
          ctx.textAlign = 'center';
          const tierLabel = data.tier ? ' (T' + data.tier + ')' : '';
          ctx.fillText(data.name.toUpperCase() + tierLabel, cx, cy - 42);
          ctx.font = '9px Share Tech Mono';
          ctx.fillStyle = '#6b7a8d';
          if (type === 'boss') {
            ctx.fillText(data.style + ' | DMG ' + data.dmg + ' | CD ' + data.cd + 'ms', cx, cy + 42);
            ctx.fillText('HP ' + data.hp + ' | ' + data.buff, cx, cy + 54);
          } else {
            ctx.fillText(data.desc, cx, cy + 42);
            const shieldStr = data.shield ? ' | SH ' + data.shield : '';
            ctx.fillText('HP ' + data.hp + shieldStr + ' | DMG ' + data.dmg + ' | CD ' + data.cd + 'ms', cx, cy + 54);
          }
        }

        // 총알 그리기
        for (const b of bullets) {
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = b.color;
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
          ctx.globalAlpha = 0.3;
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r*2, 0, Math.PI*2); ctx.fill();
        }
        // 드론 그리기
        for (const d of drones) {
          ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.angle);
          ctx.fillStyle = d.color; ctx.globalAlpha = 0.8;
          ctx.beginPath(); ctx.moveTo(d.r,0); ctx.lineTo(-d.r*0.7,-d.r*0.7); ctx.lineTo(-d.r*0.7,d.r*0.7); ctx.closePath(); ctx.fill();
          ctx.restore();
        }
        // 펄스 그리기
        for (const p of pulses) {
          ctx.globalAlpha = p.alpha * 0.4;
          ctx.fillStyle = p.color;
          ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
          ctx.globalAlpha = p.alpha;
          ctx.strokeStyle = p.color; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.stroke();
        }
        ctx.globalAlpha = 1;

        previewAnim = requestAnimationFrame(frame);
      }
      previewAnim = requestAnimationFrame(frame);

      // 정보 텍스트
      const info = document.getElementById('previewInfo');
      if (info) {
        if (previewFilter === 'all') info.textContent = 'All bosses and player classes';
        else if (isBoss) info.textContent = isBoss.name + ' — ' + isBoss.style + ' attack | ' + isBoss.buff;
        else if (isClass) info.textContent = isClass.name + ' — ' + isClass.desc;
      }
    }

    // ══════════════════════════════════════════════════════
    // ── Battle Test Mode ──
    // ══════════════════════════════════════════════════════

    let btBalance = null; // fetched balance data
    let btAnim = null;
    let btRunning = false;
    let btPaused = false;
    let btPlayer = null;
    let btEnemy = null;
    let btBullets = [];
    let btDrones = [];
    let btPulses = [];
    let btElapsed = 0;
    let btLastTime = 0;
    let btWinner = null;

    // CLASS_COLORS for player classes (must match renderer.js)
    const BT_CLASS_COLORS = {
      resistor: '#a0aec0', capacitor: '#fbbf24', repeater: '#34d399',
      inductor: '#a855f7', transformer: '#10b981', oscillator: '#06b6d4', amplifier: '#ef4444',
    };

    // ── Fetch balance data ──
    function btFetchBalance() {
      api('GET', '/api/admin/balance-data').then(data => {
        btBalance = data;
        document.getElementById('battleNotLoaded').style.display = 'none';
        document.getElementById('battleContainer').style.display = 'block';
        btUpdateEnemyOptions();
        btUpdateInfo();
        btDrawIdle();
      }).catch(() => {
        document.getElementById('battleNotLoaded').textContent = 'Failed to load balance data';
      });
    }

    // ── Level scaling helpers ──
    function btClampLevel(lv) { return Math.max(1, Math.min(20, Math.floor(lv) || 1)); }
    function btScaleHp(base, level, growth) { return Math.round((base || 100) * (1 + (growth?.hp || 0.08) * (btClampLevel(level) - 1))); }
    function btScaleDmg(base, level, growth) { return (base || 0) * (1 + (growth?.damage || 0.05) * (btClampLevel(level) - 1)); }
    function btScaleSpd(base, level, growth) { return (base || 100) * (1 + (growth?.speed || 0.01) * (btClampLevel(level) - 1)); }

    // ── Entity factory ──
    function btCreatePlayerEntity(className, level) {
      const cls = btBalance.classes[className];
      if (!cls) return null;
      const g = btBalance.levelGrowth;
      const hp = btScaleHp(cls.hp, level, g);
      const dmg = btScaleDmg(cls.attackDamage, level, g);
      const spd = btScaleSpd(cls.speed, level, g);
      return {
        type: 'player', name: cls.name, className,
        x: 200, y: 225, radius: btBalance.playerRadius || 20,
        hp, maxHp: hp, dmg, speed: spd, alive: true,
        color: BT_CLASS_COLORS[className] || '#a0aec0',
        attackType: cls.attackType,
        attackRange: cls.attackRange,
        attackCooldown: cls.attackCooldown,
        bulletSpeed: cls.bulletSpeed,
        bulletRadius: cls.bulletRadius || 4,
        bulletLifetime: cls.bulletLifetime || 1500,
        // orbit
        orbCount: cls.orbCount || 0,
        orbRadius: cls.orbRadius || 0,
        orbSpeed: cls.orbSpeed || 0,
        orbSize: cls.orbSize || 10,
        orbHitCooldown: cls.orbHitCooldown || 700,
        orbAngle: 0,
        orbLastHit: 0,
        // burst
        burstCount: cls.burstCount || 1,
        burstDelay: cls.burstDelay || 0,
        burstCooldown: cls.burstCooldown || 0,
        burstRemaining: 0,
        burstTimer: 0,
        // amplifier distance scaling
        distanceDmgScale: cls.distanceDmgScale || false,
        maxDmgMultiplier: cls.maxDmgMultiplier || 1,
        // oscillator multi-shot
        multiShot: cls.multiShot || 0,
        spreadAngle: cls.spreadAngle || 0,
        // amplifier amped shots
        ampedEvery: cls.ampedEvery || 0,
        ampedDmgMultiplier: cls.ampedDmgMultiplier || 3,
        ampedBulletRadius: cls.ampedBulletRadius || 6,
        // transformer aura
        aura: cls.aura || false,
        auraRange: cls.auraRange || 0,
        auraDmgBoost: cls.auraDmgBoost || 0,
        auraRegen: cls.auraRegen || 0,
        // shield
        shield: cls.shieldMax || 0,
        maxShield: cls.shieldMax || 0,
        shieldRechargeDelay: cls.shieldRechargeDelay || 5000,
        shieldRechargeRate: cls.shieldRechargeRate || 0,
        shieldRechargeTimer: 0,
        // magnetic pull
        magneticPull: cls.magneticPull || false,
        magneticRange: cls.magneticRange || 0,
        magneticForce: cls.magneticForce || 0,
        // tracking
        fireCooldown: 0,
        totalDmgDealt: 0,
        level,
      };
    }

    function btCreateBossEntity(bossIdx) {
      const boss = btBalance.monsterTypes[bossIdx];
      const hp = boss.hp || 500;
      return {
        type: 'boss', name: boss.name,
        x: 700, y: 225, radius: btBalance.monsterRadius || 35,
        hp, maxHp: hp, alive: true,
        color: boss.color,
        attackStyle: boss.attackStyle,
        attackDamage: boss.attackDamage,
        attackCooldown: boss.attackCooldown,
        bulletCount: boss.bulletCount || 1,
        spreadAngle: boss.spreadAngle || 0,
        bulletSpeed: boss.bulletSpeed || btBalance.bossBulletSpeed || 300,
        droneCount: boss.droneCount || 0,
        maxDrones: boss.maxDrones || 0,
        pulseRadius: boss.pulseRadius || btBalance.bossPulseRadius || 200,
        dmg: boss.attackDamage,
        speed: 0, shield: 0, maxShield: 0,
        fireCooldown: 0,
        totalDmgDealt: 0,
        pulseActive: false, pulseTimer: 0, pulseCurrentRadius: 0,
      };
    }

    function btCreateNeutralEntity(typeKey) {
      const mob = btBalance.neutralMobTypes[typeKey];
      return {
        type: 'neutral', name: mob.name,
        x: 700, y: 225, radius: mob.radius,
        hp: mob.hp, maxHp: mob.hp, alive: true,
        color: mob.color,
        attackDamage: mob.attackDamage || 0,
        attackRange: mob.attackRange || 0,
        attackCooldown: mob.attackCooldown || 9999,
        behavior: mob.behavior,
        dmg: mob.attackDamage || 0,
        speed: 0, shield: 0, maxShield: 0,
        fireCooldown: 0,
        totalDmgDealt: 0,
        attackType: mob.behavior === 'defensive' ? 'melee' : 'none',
      };
    }

    function btCreateCellEntity() {
      const cb = btBalance.cellBalance;
      return {
        type: 'cell', name: 'Cell Turret',
        x: 700, y: 225, radius: cb.radius,
        hp: cb.maxHp, maxHp: cb.maxHp, alive: true,
        color: '#22c55e',
        attackDamage: cb.attackDamage,
        attackRange: cb.attackRange,
        attackCooldown: cb.attackCooldown,
        dmg: cb.attackDamage,
        speed: 0, shield: 0, maxShield: 0,
        fireCooldown: 0,
        totalDmgDealt: 0,
        attackType: 'turret',
        bulletSpeed: 400,
        bulletRadius: 5,
        overheat: 0,
        overheatChargeRate: cb.overheatChargeRate,
        overheatThreshold: cb.overheatThreshold,
        overheatMinCooldown: cb.overheatMinCooldown,
      };
    }

    function btCreateMinionEntity() {
      const ms = btBalance.minionStats;
      return {
        type: 'minion', name: 'Minion',
        x: 700, y: 225, radius: ms.radius,
        hp: ms.hp, maxHp: ms.hp, alive: true,
        color: '#ff6b80',
        attackDamage: ms.damage,
        attackRange: ms.attackRange,
        attackCooldown: ms.attackCooldown,
        dmg: ms.damage,
        speed: ms.speed, shield: 0, maxShield: 0,
        fireCooldown: 0,
        totalDmgDealt: 0,
        attackType: 'melee',
      };
    }

    // ── UI update helpers ──
    function btUpdateEnemyOptions() {
      const cat = document.getElementById('btEnemyCategory').value;
      const sel = document.getElementById('btEnemyType');
      const levelWrap = document.getElementById('btEnemyLevelWrap');
      sel.innerHTML = '';
      if (cat === 'class') {
        Object.keys(btBalance.classes).forEach(k => {
          const o = document.createElement('option');
          o.value = k; o.textContent = btBalance.classes[k].name;
          sel.appendChild(o);
        });
        levelWrap.style.display = 'flex';
      } else if (cat === 'boss') {
        btBalance.monsterTypes.forEach((m, i) => {
          const o = document.createElement('option');
          o.value = i; o.textContent = m.name + ' (' + m.attackStyle + ')';
          sel.appendChild(o);
        });
        levelWrap.style.display = 'none';
      } else if (cat === 'neutral') {
        Object.keys(btBalance.neutralMobTypes).forEach(k => {
          const o = document.createElement('option');
          o.value = k; o.textContent = btBalance.neutralMobTypes[k].name;
          sel.appendChild(o);
        });
        levelWrap.style.display = 'none';
      } else if (cat === 'cell') {
        const o = document.createElement('option');
        o.value = 'cell'; o.textContent = 'Cell Turret';
        sel.appendChild(o);
        levelWrap.style.display = 'none';
      } else if (cat === 'minion') {
        const o = document.createElement('option');
        o.value = 'minion'; o.textContent = 'Minion';
        sel.appendChild(o);
        levelWrap.style.display = 'none';
      }
      btUpdateInfo();
    }

    function btUpdateInfo() {
      if (!btBalance) return;
      // Player info
      const pCls = document.getElementById('btPlayerClass').value;
      const pLv = parseInt(document.getElementById('btPlayerLevel').value);
      document.getElementById('btPlayerLevelLabel').textContent = 'Lv.' + pLv;
      const cls = btBalance.classes[pCls];
      if (cls) {
        const g = btBalance.levelGrowth;
        document.getElementById('btPlayerInfo').innerHTML =
          `<span class="bei-hp">HP ${btScaleHp(cls.hp, pLv, g)}</span> ` +
          `<span class="bei-dmg">DMG ${btScaleDmg(cls.attackDamage, pLv, g).toFixed(1)}</span> ` +
          `<span class="bei-spd">SPD ${btScaleSpd(cls.speed, pLv, g).toFixed(0)}</span>` +
          (cls.shieldMax ? `<br>Shield: ${cls.shieldMax}` : '') +
          `<br>${cls.attackType} | CD ${cls.attackCooldown}ms | Range ${cls.attackRange}px`;
      }
      // Enemy info
      const eCat = document.getElementById('btEnemyCategory').value;
      const eType = document.getElementById('btEnemyType').value;
      const eLv = parseInt(document.getElementById('btEnemyLevel').value);
      document.getElementById('btEnemyLevelLabel').textContent = 'Lv.' + eLv;
      const eInfo = document.getElementById('btEnemyInfo');
      if (eCat === 'class') {
        const ec = btBalance.classes[eType];
        if (ec) {
          const g = btBalance.levelGrowth;
          eInfo.innerHTML =
            `<span class="bei-hp">HP ${btScaleHp(ec.hp, eLv, g)}</span> ` +
            `<span class="bei-dmg">DMG ${btScaleDmg(ec.attackDamage, eLv, g).toFixed(1)}</span> ` +
            `<span class="bei-spd">SPD ${btScaleSpd(ec.speed, eLv, g).toFixed(0)}</span>` +
            (ec.shieldMax ? `<br>Shield: ${ec.shieldMax}` : '') +
            `<br>${ec.attackType} | CD ${ec.attackCooldown}ms | Range ${ec.attackRange}px`;
        }
      } else if (eCat === 'boss') {
        const boss = btBalance.monsterTypes[parseInt(eType)];
        if (boss) {
          eInfo.innerHTML =
            `<span class="bei-hp">HP ${boss.hp}</span> ` +
            `<span class="bei-dmg">DMG ${boss.attackDamage}</span>` +
            `<br>${boss.attackStyle} | CD ${boss.attackCooldown}ms | ${boss.label || ''}`;
        }
      } else if (eCat === 'neutral') {
        const nm = btBalance.neutralMobTypes[eType];
        if (nm) eInfo.innerHTML = `<span class="bei-hp">HP ${nm.hp}</span> | ${nm.behavior}` + (nm.attackDamage ? ` | DMG ${nm.attackDamage}` : '');
      } else if (eCat === 'cell') {
        const cb = btBalance.cellBalance;
        eInfo.innerHTML = `<span class="bei-hp">HP ${cb.maxHp}</span> <span class="bei-dmg">DMG ${cb.attackDamage}</span><br>Range ${cb.attackRange}px | CD ${cb.attackCooldown}ms`;
      } else if (eCat === 'minion') {
        const ms = btBalance.minionStats;
        eInfo.innerHTML = `<span class="bei-hp">HP ${ms.hp}</span> <span class="bei-dmg">DMG ${ms.damage}</span><br>Melee | Range ${ms.attackRange}px`;
      }
    }

    // ── Create enemy based on UI ──
    function btCreateEnemy() {
      const cat = document.getElementById('btEnemyCategory').value;
      const typ = document.getElementById('btEnemyType').value;
      const lv = parseInt(document.getElementById('btEnemyLevel').value);
      if (cat === 'class') {
        const e = btCreatePlayerEntity(typ, lv);
        if (e) { e.x = 700; e.color = BT_CLASS_COLORS[typ] || '#ff6b80'; }
        return e;
      }
      if (cat === 'boss') return btCreateBossEntity(parseInt(typ));
      if (cat === 'neutral') return btCreateNeutralEntity(typ);
      if (cat === 'cell') return btCreateCellEntity();
      if (cat === 'minion') return btCreateMinionEntity();
      return null;
    }

    // ── Damage application ──
    function btApplyDamage(target, dmg, source) {
      if (!target.alive) return;
      let remaining = dmg;
      // Shield absorb
      if (target.shield > 0) {
        const absorbed = Math.min(target.shield, remaining);
        target.shield -= absorbed;
        remaining -= absorbed;
        if (target.shield <= 0) target.shieldRechargeTimer = target.shieldRechargeDelay || 5000;
      }
      target.hp -= remaining;
      if (source) source.totalDmgDealt += dmg;
      if (target.hp <= 0) { target.hp = 0; target.alive = false; }
    }

    // ── Attack logic per entity ──
    function btEntityAttack(entity, target, dt) {
      if (!entity.alive || !target.alive) return;
      const dx = target.x - entity.x;
      const dy = target.y - entity.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);

      // Shield recharge
      if (entity.maxShield > 0 && entity.shield < entity.maxShield) {
        if (entity.shieldRechargeTimer > 0) {
          entity.shieldRechargeTimer -= dt * 1000;
        } else {
          entity.shield = Math.min(entity.maxShield, entity.shield + (entity.shieldRechargeRate || 20) * dt);
        }
      }

      // Movement: all mobile entities move toward target when out of effective range
      const moveSpeed = entity.speed || 0;
      if (moveSpeed > 0) {
        let effectiveRange;
        if (entity.attackType === 'orbit') {
          effectiveRange = (entity.orbRadius || 90) + (entity.orbSize || 10);
        } else if (entity.attackType === 'melee') {
          effectiveRange = (entity.attackRange || 30) + target.radius;
        } else {
          effectiveRange = (entity.attackRange || 280) * 0.8; // move until 80% of range for some breathing room
        }
        if (dist > effectiveRange) {
          entity.x += Math.cos(angle) * moveSpeed * dt;
          entity.y += Math.sin(angle) * moveSpeed * dt;
          entity.x = Math.max(30, Math.min(870, entity.x));
          entity.y = Math.max(30, Math.min(420, entity.y));
        }
      }

      // Magnetic pull (Inductor)
      if (entity.magneticPull && dist <= entity.magneticRange && dist > entity.orbRadius) {
        const pullStr = entity.magneticForce * dt;
        const pullAngle = Math.atan2(entity.y - target.y, entity.x - target.x);
        target.x += Math.cos(pullAngle) * pullStr;
        target.y += Math.sin(pullAngle) * pullStr;
        target.x = Math.max(50, Math.min(850, target.x));
      }

      // Orbit attack (capacitor/inductor/transformer)
      if (entity.attackType === 'orbit' && entity.orbCount > 0) {
        entity.orbAngle += (entity.orbSpeed || 2.8) * dt;
        for (let i = 0; i < entity.orbCount; i++) {
          const oa = entity.orbAngle + (Math.PI * 2 / entity.orbCount) * i;
          const ox = entity.x + Math.cos(oa) * entity.orbRadius;
          const oy = entity.y + Math.sin(oa) * entity.orbRadius;
          const odx = target.x - ox;
          const ody = target.y - oy;
          const oDist = Math.sqrt(odx * odx + ody * ody);
          if (oDist < (entity.orbSize || 10) + target.radius) {
            const now = btElapsed * 1000;
            if (now - (entity.orbLastHit || 0) >= entity.orbHitCooldown) {
              entity.orbLastHit = now;
              btApplyDamage(target, entity.dmg, entity);
            }
          }
        }
        return;
      }

      // Melee attack (minion, neutral mob)
      if (entity.attackType === 'melee') {
        if (dist <= (entity.attackRange || 30) + target.radius) {
          entity.fireCooldown -= dt * 1000;
          if (entity.fireCooldown <= 0) {
            entity.fireCooldown = entity.attackCooldown;
            btApplyDamage(target, entity.dmg, entity);
          }
        }
        return;
      }

      // Turret attack (cell)
      if (entity.attackType === 'turret') {
        if (dist <= entity.attackRange) {
          // Overheat charge
          if (entity.overheat !== undefined) {
            entity.overheat = Math.min(1, entity.overheat + (entity.overheatChargeRate || 0.12) * dt);
          }
          let cd = entity.attackCooldown;
          if (entity.overheat >= (entity.overheatThreshold || 0.6)) {
            const ratio = (entity.overheat - entity.overheatThreshold) / (1 - entity.overheatThreshold);
            cd = entity.attackCooldown - (entity.attackCooldown - (entity.overheatMinCooldown || 400)) * ratio;
          }
          entity.fireCooldown -= dt * 1000;
          if (entity.fireCooldown <= 0) {
            entity.fireCooldown = cd;
            btBullets.push({
              x: entity.x, y: entity.y, angle, speed: entity.bulletSpeed || 400,
              radius: entity.bulletRadius || 5, dmg: entity.dmg, life: 2,
              color: entity.color, owner: 'enemy', originX: entity.x, originY: entity.y,
            });
          }
        } else if (entity.overheat > 0) {
          // Overheat decay when out of range
          entity.overheat = Math.max(0, entity.overheat - (btBalance.cellBalance.overheatDecayRate || 0.08) * dt);
        }
        return;
      }

      // Boss attack patterns
      if (entity.type === 'boss') {
        entity.fireCooldown -= dt * 1000;
        if (entity.fireCooldown <= 0) {
          entity.fireCooldown = entity.attackCooldown;
          const spd = entity.bulletSpeed || btBalance.bossBulletSpeed || 300;
          const bRad = btBalance.bossBulletRadius || 6;
          if (entity.attackStyle === 'spray') {
            for (let i = 0; i < (entity.bulletCount || 3); i++) {
              const sa = entity.spreadAngle || 0.4;
              const a = angle + (i - (entity.bulletCount - 1) / 2) * sa;
              btBullets.push({ x: entity.x, y: entity.y, angle: a, speed: spd, radius: bRad, dmg: entity.dmg, life: 2, color: entity.color, owner: 'enemy', originX: entity.x, originY: entity.y });
            }
          } else if (entity.attackStyle === 'sniper') {
            btBullets.push({ x: entity.x, y: entity.y, angle, speed: spd, radius: bRad + 2, dmg: entity.dmg, life: 2, color: entity.color, owner: 'enemy', originX: entity.x, originY: entity.y });
          } else if (entity.attackStyle === 'drone') {
            const currentDrones = btDrones.filter(d => d.owner === 'enemy' && d.life > 0).length;
            if (currentDrones < (entity.maxDrones || 4)) {
              btDrones.push({
                x: entity.x, y: entity.y, angle: Math.random() * Math.PI * 2,
                speed: btBalance.bossDroneSpeed || 100, radius: btBalance.bossDroneRadius || 10,
                hp: btBalance.bossDroneHp || 30, dmg: btBalance.bossDroneDamage || 8,
                life: (btBalance.bossDroneLifetime || 6000) / 1000,
                color: entity.color, owner: 'enemy', attackCd: 0,
              });
            }
          } else if (entity.attackStyle === 'pulse') {
            btPulses.push({ x: entity.x, y: entity.y, r: 0, maxR: entity.pulseRadius || 200, alpha: 0.8, color: entity.color, dmg: entity.dmg, owner: 'enemy', hit: false });
          } else if (entity.attackStyle === 'twin') {
            const perp = angle + Math.PI / 2;
            for (const s of [-1, 1]) {
              btBullets.push({
                x: entity.x + Math.cos(perp) * 8 * s, y: entity.y + Math.sin(perp) * 8 * s,
                angle, speed: spd, radius: bRad, dmg: entity.dmg, life: 2,
                color: entity.color, owner: 'enemy', originX: entity.x, originY: entity.y,
              });
            }
          }
        }
        return;
      }

      // Player projectile attack (single / burst)
      if (!entity.attackRange || dist > entity.attackRange) return;
      entity.fireCooldown -= dt * 1000;

      if (entity.attackType === 'burst') {
        if (entity.burstRemaining > 0) {
          entity.burstTimer -= dt * 1000;
          if (entity.burstTimer <= 0) {
            entity.burstTimer = entity.burstDelay || 80;
            entity.burstRemaining--;
            btBullets.push({
              x: entity.x, y: entity.y, angle, speed: entity.bulletSpeed || 500,
              radius: entity.bulletRadius || 3, dmg: entity.dmg, life: 1.5,
              color: entity.color, owner: 'player',
              originX: entity.x, originY: entity.y,
              distScale: entity.distanceDmgScale, maxDmgMul: entity.maxDmgMultiplier,
            });
          }
        } else if (entity.fireCooldown <= 0) {
          entity.fireCooldown = entity.burstCooldown || 450;
          entity.burstRemaining = (entity.burstCount || 3) - 1;
          entity.burstTimer = entity.burstDelay || 80;
          btBullets.push({
            x: entity.x, y: entity.y, angle, speed: entity.bulletSpeed || 500,
            radius: entity.bulletRadius || 3, dmg: entity.dmg, life: 1.5,
            color: entity.color, owner: 'player',
            originX: entity.x, originY: entity.y,
            distScale: entity.distanceDmgScale, maxDmgMul: entity.maxDmgMultiplier,
          });
        }
        return;
      }

      if (entity.fireCooldown <= 0) {
        entity.fireCooldown = entity.attackCooldown;
        const owner = entity === btPlayer ? 'player' : 'enemy';

        // Track shot count for ampedEvery
        if (!entity._shotCount) entity._shotCount = 0;
        entity._shotCount++;

        // Oscillator: multiShot spread
        if (entity.multiShot && entity.multiShot > 1) {
          const spreadA = entity.spreadAngle || 0.25;
          for (let i = 0; i < entity.multiShot; i++) {
            const sa = angle + (i - (entity.multiShot - 1) / 2) * spreadA;
            btBullets.push({
              x: entity.x, y: entity.y, angle: sa, speed: entity.bulletSpeed || 500,
              radius: entity.bulletRadius || 3, dmg: entity.dmg, life: 1.5,
              color: entity.color, owner,
              originX: entity.x, originY: entity.y,
            });
          }
        }
        // Amplifier: amped shot every N-th
        else if (entity.ampedEvery && entity._shotCount % entity.ampedEvery === 0) {
          const ampDmg = entity.dmg * (entity.ampedDmgMultiplier || 3);
          btBullets.push({
            x: entity.x, y: entity.y, angle, speed: entity.bulletSpeed || 500,
            radius: entity.ampedBulletRadius || 6, dmg: ampDmg, life: 1.5,
            color: '#fbbf24', owner,
            originX: entity.x, originY: entity.y,
          });
        }
        // Normal single shot
        else {
          btBullets.push({
            x: entity.x, y: entity.y, angle, speed: entity.bulletSpeed || 500,
            radius: entity.bulletRadius || 4, dmg: entity.dmg, life: 1.5,
            color: entity.color, owner,
            originX: entity.x, originY: entity.y,
            distScale: entity.distanceDmgScale, maxDmgMul: entity.maxDmgMultiplier,
          });
        }
      }
    }

    // ── Simulation frame ──
    function btFrame(now) {
      if (!btRunning) return;
      if (btPaused) { btAnim = requestAnimationFrame(btFrame); return; }
      const dt = Math.min((now - btLastTime) / 1000, 0.1);
      btLastTime = now;
      btElapsed += dt;

      // Transformer aura self-regen
      for (const ent of [btPlayer, btEnemy]) {
        if (ent.alive && ent.aura && ent.auraRegen > 0) {
          ent.hp = Math.min(ent.maxHp, ent.hp + ent.auraRegen * dt);
        }
      }

      // Update attacks
      if (btPlayer.alive && btEnemy.alive) {
        btEntityAttack(btPlayer, btEnemy, dt);
        btEntityAttack(btEnemy, btPlayer, dt);
      }

      // Update bullets
      for (const b of btBullets) {
        b.x += Math.cos(b.angle) * b.speed * dt;
        b.y += Math.sin(b.angle) * b.speed * dt;
        b.life -= dt;
        // Collision check
        const target = b.owner === 'player' ? btEnemy : btPlayer;
        if (target.alive) {
          const bdx = target.x - b.x;
          const bdy = target.y - b.y;
          const bDist = Math.sqrt(bdx * bdx + bdy * bdy);
          if (bDist < b.radius + target.radius) {
            let dmg = b.dmg;
            // Distance dmg scale (Amplifier)
            if (b.distScale) {
              const travDist = Math.sqrt((b.x - b.originX) ** 2 + (b.y - b.originY) ** 2);
              const maxRange = btBalance.classes.amplifier?.attackRange || 400;
              const ratio = Math.min(travDist / maxRange, 1);
              dmg *= (1 + (b.maxDmgMul - 1) * ratio);
            }
            const src = b.owner === 'player' ? btPlayer : btEnemy;
            btApplyDamage(target, dmg, src);
            b.life = 0;
          }
        }
      }
      btBullets = btBullets.filter(b => b.life > 0 && b.x > -50 && b.x < 950 && b.y > -50 && b.y < 500);

      // Update drones
      for (const d of btDrones) {
        d.life -= dt;
        const target = d.owner === 'enemy' ? btPlayer : btEnemy;
        if (target.alive) {
          const ddx = target.x - d.x;
          const ddy = target.y - d.y;
          const dDist = Math.sqrt(ddx * ddx + ddy * ddy);
          d.angle = Math.atan2(ddy, ddx);
          d.x += Math.cos(d.angle) * d.speed * dt;
          d.y += Math.sin(d.angle) * d.speed * dt;
          // Contact damage
          if (dDist < d.radius + target.radius) {
            d.attackCd -= dt * 1000;
            if (d.attackCd <= 0) {
              d.attackCd = 1000;
              const src = d.owner === 'enemy' ? btEnemy : btPlayer;
              btApplyDamage(target, d.dmg, src);
            }
          }
        }
      }
      btDrones = btDrones.filter(d => d.life > 0);

      // Update pulses
      for (const p of btPulses) {
        p.r += 300 * dt;
        p.alpha -= 1.5 * dt;
        // Pulse damage
        if (!p.hit && p.r > 0) {
          const target = p.owner === 'enemy' ? btPlayer : btEnemy;
          if (target.alive) {
            const pdx = target.x - p.x;
            const pdy = target.y - p.y;
            const pDist = Math.sqrt(pdx * pdx + pdy * pdy);
            if (pDist < p.r + target.radius && pDist > p.r - 30) {
              const src = p.owner === 'enemy' ? btEnemy : btPlayer;
              btApplyDamage(target, p.dmg, src);
              p.hit = true;
            }
          }
        }
      }
      btPulses = btPulses.filter(p => p.alpha > 0);

      // Check winner
      if (!btPlayer.alive && btWinner === null) {
        btWinner = btEnemy.name;
        document.getElementById('btStatWinner').textContent = btEnemy.name + ' WINS';
        document.getElementById('btStatWinnerCard').classList.add('winner');
        document.getElementById('btStatTtk').textContent = btElapsed.toFixed(2) + 's';
      }
      if (!btEnemy.alive && btWinner === null) {
        btWinner = btPlayer.name;
        document.getElementById('btStatWinner').textContent = btPlayer.name + ' WINS';
        document.getElementById('btStatWinnerCard').classList.add('winner');
        document.getElementById('btStatTtk').textContent = btElapsed.toFixed(2) + 's';
      }

      // Update stats
      const pDps = btElapsed > 0 ? (btPlayer.totalDmgDealt / btElapsed).toFixed(1) : '0';
      const eDps = btElapsed > 0 ? (btEnemy.totalDmgDealt / btElapsed).toFixed(1) : '0';
      document.getElementById('btStatPlayerDps').textContent = pDps;
      document.getElementById('btStatEnemyDps').textContent = eDps;
      document.getElementById('btStatTime').textContent = btElapsed.toFixed(1) + 's';

      btRender();

      if (btPlayer.alive && btEnemy.alive) {
        btAnim = requestAnimationFrame(btFrame);
      } else {
        // One more frame after death for final render
        btRunning = false;
      }
    }

    // ── Render ──
    function btRender() {
      const cvs = document.getElementById('battleCanvas');
      if (!cvs) return;
      const ctx = cvs.getContext('2d');
      const W = cvs.width, H = cvs.height;
      ctx.clearRect(0, 0, W, H);

      // Grid
      ctx.strokeStyle = '#1a2030';
      ctx.lineWidth = 0.5;
      for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
      for (let y = 0; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

      // Distance line
      if (btPlayer && btEnemy) {
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = '#2a3a4e';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(btPlayer.x, btPlayer.y); ctx.lineTo(btEnemy.x, btEnemy.y); ctx.stroke();
        ctx.setLineDash([]);
        const dist = Math.sqrt((btEnemy.x - btPlayer.x) ** 2 + (btEnemy.y - btPlayer.y) ** 2);
        ctx.font = '10px Share Tech Mono';
        ctx.fillStyle = '#4a5568';
        ctx.textAlign = 'center';
        ctx.fillText(Math.round(dist) + 'px', (btPlayer.x + btEnemy.x) / 2, (btPlayer.y + btEnemy.y) / 2 - 8);
        ctx.restore();
      }

      // Draw entities
      if (btPlayer) btDrawEntity(ctx, btPlayer, 'left');
      if (btEnemy) btDrawEntity(ctx, btEnemy, 'right');

      // Draw bullets
      for (const b of btBullets) {
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = b.color;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 0.3;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.radius * 2, 0, Math.PI * 2); ctx.fill();
      }

      // Draw drones
      for (const d of btDrones) {
        ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.angle);
        ctx.fillStyle = d.color; ctx.globalAlpha = 0.8;
        ctx.beginPath(); ctx.moveTo(d.radius, 0); ctx.lineTo(-d.radius * 0.7, -d.radius * 0.7); ctx.lineTo(-d.radius * 0.7, d.radius * 0.7); ctx.closePath(); ctx.fill();
        ctx.restore();
      }

      // Draw pulses
      for (const p of btPulses) {
        ctx.globalAlpha = p.alpha * 0.3;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = p.alpha;
        ctx.strokeStyle = p.color; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.stroke();
      }

      ctx.globalAlpha = 1;

      // Title overlay
      ctx.font = 'bold 12px Orbitron';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#ffd700';
      ctx.fillText('BATTLE TEST', 10, 20);
      if (btWinner) {
        ctx.font = 'bold 24px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd700';
        ctx.fillText(btWinner + ' WINS', W / 2, H / 2 - 10);
        ctx.font = '14px Share Tech Mono';
        ctx.fillStyle = '#6b7a8d';
        ctx.fillText('TTK: ' + btElapsed.toFixed(2) + 's', W / 2, H / 2 + 16);
      }
    }

    function btDrawEntity(ctx, e, side) {
      if (!e) return;
      const r = e.radius;
      const x = e.x, y = e.y;

      // Range circle
      if (e.attackRange) {
        ctx.globalAlpha = 0.06;
        ctx.fillStyle = e.color;
        ctx.beginPath(); ctx.arc(x, y, e.attackRange, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 0.15;
        ctx.strokeStyle = e.color;
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath(); ctx.arc(x, y, e.attackRange, 0, Math.PI * 2); ctx.stroke();
        ctx.setLineDash([]);
      }

      ctx.globalAlpha = e.alive ? 0.9 : 0.3;

      // Body shape
      if (e.type === 'boss') {
        ctx.fillStyle = e.color;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
        // Attack style barrel indicators
        ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.4;
        if (e.attackStyle === 'spray') {
          for (let i = -1; i <= 1; i++) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(i * 0.4);
            ctx.fillRect(r * 0.3, -2, r * 0.6, 4); ctx.restore();
          }
        } else if (e.attackStyle === 'sniper') {
          ctx.fillRect(x + r * 0.2, y - 3, r * 0.9, 6);
        } else if (e.attackStyle === 'twin') {
          ctx.fillRect(x + r * 0.3, y - 8, r * 0.5, 4);
          ctx.fillRect(x + r * 0.3, y + 4, r * 0.5, 4);
        } else if (e.attackStyle === 'drone') {
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
          ctx.strokeRect(x - r * 0.4, y - r * 0.4, r * 0.8, r * 0.8);
        }
      } else if (e.type === 'cell') {
        // Capacitor symbol
        ctx.fillStyle = e.color;
        ctx.fillRect(x - r, y - 3, r * 2, 6);
        ctx.fillRect(x - 3, y - r, 6, r * 2);
        ctx.strokeStyle = e.color; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.stroke();
      } else if (e.type === 'minion') {
        ctx.fillStyle = e.color;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      } else if (e.type === 'neutral') {
        ctx.fillStyle = e.color;
        const sides = e.name === 'Photon' ? 3 : e.name === 'Dopant' ? 4 : 5;
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
          const a = (Math.PI * 2 / sides) * i - Math.PI / 2;
          const px = x + Math.cos(a) * r;
          const py = y + Math.sin(a) * r;
          if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath(); ctx.fill();
      } else {
        // Player class
        const aim = btEnemy && e === btPlayer ? Math.atan2(btEnemy.y - y, btEnemy.x - x) : (btPlayer ? Math.atan2(btPlayer.y - y, btPlayer.x - x) : 0);
        if (e.attackType === 'orbit') {
          ctx.fillStyle = e.color;
          ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
          // Shield ring
          if (e.maxShield > 0) {
            ctx.globalAlpha = 0.3 * (e.shield / e.maxShield);
            ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(x, y, r + 6, 0, Math.PI * 2); ctx.stroke();
          }
          // Aura ring (Transformer)
          if (e.aura) {
            ctx.globalAlpha = 0.1;
            ctx.strokeStyle = e.color; ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.arc(x, y, e.auraRange || 200, 0, Math.PI * 2); ctx.stroke();
            ctx.setLineDash([]);
          }
          // Magnetic pull arcs (Inductor)
          if (e.magneticPull) {
            ctx.globalAlpha = 0.15; ctx.strokeStyle = e.color; ctx.lineWidth = 1.5;
            const t = btElapsed * 2;
            for (let ring = 1; ring <= 3; ring++) {
              const rr = r + 10 + ring * 12;
              ctx.beginPath(); ctx.arc(x, y, rr, -0.4 + t, 0.4 + t); ctx.stroke();
              ctx.beginPath(); ctx.arc(x, y, rr, Math.PI - 0.4 + t, Math.PI + 0.4 + t); ctx.stroke();
            }
          }
          // Orbital orbs
          ctx.globalAlpha = e.alive ? 1 : 0.3;
          for (let i = 0; i < e.orbCount; i++) {
            const oa = (e.orbAngle || 0) + (Math.PI * 2 / e.orbCount) * i;
            const ox = x + Math.cos(oa) * e.orbRadius;
            const oy = y + Math.sin(oa) * e.orbRadius;
            ctx.fillStyle = e.color;
            ctx.beginPath(); ctx.arc(ox, oy, e.orbSize * 0.6, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
          }
        } else {
          // Triangle player (resistor / repeater / oscillator / amplifier)
          ctx.save(); ctx.translate(x, y); ctx.rotate(aim);
          ctx.fillStyle = e.color;
          if (e.className === 'oscillator') {
            // Wider triangle for oscillator
            ctx.beginPath(); ctx.moveTo(r * 1.1, 0); ctx.lineTo(-r * 0.6, -r * 0.85); ctx.lineTo(-r * 0.6, r * 0.85); ctx.closePath(); ctx.fill();
            ctx.globalAlpha = 0.5; ctx.fillRect(r * 0.2, r * 0.4, r * 0.5, 3); ctx.fillRect(r * 0.2, -r * 0.4 - 3, r * 0.5, 3);
          } else if (e.className === 'amplifier') {
            // Amplifier with barrel
            ctx.beginPath(); ctx.moveTo(r * 1.2, 0); ctx.lineTo(-r * 0.7, -r * 0.75); ctx.lineTo(-r * 0.7, r * 0.75); ctx.closePath(); ctx.fill();
            ctx.globalAlpha = 0.5; ctx.fillRect(r * 0.3, -2.5, r * 0.7, 5);
          } else {
            ctx.beginPath(); ctx.moveTo(r, 0); ctx.lineTo(-r * 0.7, -r * 0.7); ctx.lineTo(-r * 0.7, r * 0.7); ctx.closePath(); ctx.fill();
          }
          ctx.restore();
          // Shield ring
          if (e.maxShield > 0) {
            ctx.globalAlpha = 0.3 * (e.shield / e.maxShield);
            ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(x, y, r + 5, 0, Math.PI * 2); ctx.stroke();
          }
        }
      }

      ctx.globalAlpha = 1;

      // HP bar
      const hpW = r * 2.5;
      const hpH = 5;
      const hpX = x - hpW / 2;
      const hpY = y - r - 18;
      // Background
      ctx.fillStyle = '#1a2030';
      ctx.fillRect(hpX, hpY, hpW, hpH);
      // HP fill
      const hpRatio = Math.max(0, e.hp / e.maxHp);
      const hpColor = hpRatio > 0.5 ? '#22c55e' : hpRatio > 0.25 ? '#f59e0b' : '#ef4444';
      ctx.fillStyle = hpColor;
      ctx.fillRect(hpX, hpY, hpW * hpRatio, hpH);
      // Shield bar
      if (e.maxShield > 0) {
        const shY = hpY - 4;
        ctx.fillStyle = '#1a2030';
        ctx.fillRect(hpX, shY, hpW, 3);
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(hpX, shY, hpW * Math.max(0, e.shield / e.maxShield), 3);
      }

      // HP text
      ctx.font = '10px Share Tech Mono';
      ctx.fillStyle = '#e0e6ed';
      ctx.textAlign = 'center';
      ctx.fillText(Math.ceil(e.hp) + '/' + e.maxHp, x, hpY - 3);

      // Name
      ctx.font = 'bold 11px Orbitron';
      ctx.fillStyle = e.color;
      ctx.fillText(e.name, x, hpY - 15);
    }

    // ── Draw idle state ──
    function btDrawIdle() {
      const cvs = document.getElementById('battleCanvas');
      if (!cvs) return;
      const ctx = cvs.getContext('2d');
      const W = cvs.width, H = cvs.height;
      ctx.clearRect(0, 0, W, H);
      ctx.strokeStyle = '#1a2030'; ctx.lineWidth = 0.5;
      for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
      for (let y = 0; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
      ctx.font = '16px Orbitron';
      ctx.fillStyle = '#2a3a4e';
      ctx.textAlign = 'center';
      ctx.fillText('Select entities and press START', W / 2, H / 2);
    }

    // ── Controls ──
    function btStart() {
      if (btRunning) return;
      if (!btBalance) return;
      const pCls = document.getElementById('btPlayerClass').value;
      const pLv = parseInt(document.getElementById('btPlayerLevel').value);
      btPlayer = btCreatePlayerEntity(pCls, pLv);
      btEnemy = btCreateEnemy();
      if (!btPlayer || !btEnemy) return;
      btBullets = [];
      btDrones = [];
      btPulses = [];
      btElapsed = 0;
      btWinner = null;
      btRunning = true;
      btPaused = false;
      btLastTime = performance.now();
      document.getElementById('btStartBtn').disabled = true;
      document.getElementById('btPauseBtn').disabled = false;
      document.getElementById('btStatWinner').textContent = '-';
      document.getElementById('btStatTtk').textContent = '-';
      document.getElementById('btStatWinnerCard').classList.remove('winner');
      document.getElementById('btStatPlayerDps').textContent = '0';
      document.getElementById('btStatEnemyDps').textContent = '0';
      btAnim = requestAnimationFrame(btFrame);
    }

    function btPause() {
      btPaused = !btPaused;
      document.getElementById('btPauseBtn').textContent = btPaused ? 'RESUME' : 'PAUSE';
      if (!btPaused) { btLastTime = performance.now(); }
    }

    function btReset() {
      btRunning = false;
      btPaused = false;
      if (btAnim) cancelAnimationFrame(btAnim);
      btPlayer = null;
      btEnemy = null;
      btBullets = [];
      btDrones = [];
      btPulses = [];
      btElapsed = 0;
      btWinner = null;
      document.getElementById('btStartBtn').disabled = false;
      document.getElementById('btPauseBtn').disabled = true;
      document.getElementById('btPauseBtn').textContent = 'PAUSE';
      document.getElementById('btStatPlayerDps').textContent = '-';
      document.getElementById('btStatEnemyDps').textContent = '-';
      document.getElementById('btStatTtk').textContent = '-';
      document.getElementById('btStatTime').textContent = '0.0s';
      document.getElementById('btStatWinner').textContent = '-';
      document.getElementById('btStatWinnerCard').classList.remove('winner');
      btDrawIdle();
    }

    // ── Hook into refresh flow ──
    const _origRefreshAll = refreshAll;
    refreshAll = function() {
      _origRefreshAll();
      // Fetch balance data once (on first refresh after auth)
      if (!btBalance) btFetchBalance();
    };
  </script>
</body>
</html>
